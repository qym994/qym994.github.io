<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>qym的个人主页 Blog</title>
        <link>https://qym994.github.io/</link>
        <description>qym的个人主页 Blog</description>
        <lastBuildDate>Tue, 28 Mar 2023 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>zh</language>
        <item>
            <title><![CDATA[v-for的key问题]]></title>
            <link>https://qym994.github.io/qym-vue-6</link>
            <guid>https://qym994.github.io/qym-vue-6</guid>
            <pubDate>Tue, 28 Mar 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[v-for的key问题]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="v-for的key问题">v-for的key问题<a href="#v-for的key问题" class="hash-link" aria-label="v-for的key问题的直接链接" title="v-for的key问题的直接链接">​</a></h3><p>使用v-for遍历时，v-for遍历时旧的结构和新的结构时按照顺序对比的<br>
<!-- -->在更新节点时，会比较新旧节点，由变化才会修改(diff算法)<br>
<!-- -->为元素指定一个唯一的key后就按照key去比较而不是顺序</p>]]></content:encoded>
            <category>Vue</category>
            <category>问题回顾</category>
        </item>
        <item>
            <title><![CDATA[async属性和defer属性]]></title>
            <link>https://qym994.github.io/qym-js-7</link>
            <guid>https://qym994.github.io/qym-js-7</guid>
            <pubDate>Thu, 16 Mar 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[script标签的async和defer属性]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="script标签的async和defer属性">script标签的async和defer属性<a href="#script标签的async和defer属性" class="hash-link" aria-label="script标签的async和defer属性的直接链接" title="script标签的async和defer属性的直接链接">​</a></h3><p>浏览器在进行解析的时候遇到script标签的外部文件会优先解析<br>
<!-- -->由于无法确定scipt标签中脚本的大小，为了避免阻塞引入async和defer属性  </p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="async属性--更适合第三方脚本">async属性  （更适合第三方脚本）<a href="#async属性--更适合第三方脚本" class="hash-link" aria-label="async属性  （更适合第三方脚本）的直接链接" title="async属性  （更适合第三方脚本）的直接链接">​</a></h4><p>异步执行：浏览器进行html解析，遇到带有async属性的scipt标签后，浏览器立即进行下载<br>
<!-- -->同时继续加载界面，下载完成后执行脚本（不管html是否解析完毕）<br>
<strong>注意</strong>假如脚本修改DOM节点可能会出错</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="defer属性">defer属性<a href="#defer属性" class="hash-link" aria-label="defer属性的直接链接" title="defer属性的直接链接">​</a></h4><p>推迟执行：浏览器进行html解析，遇到带有defer属性的scipt标签后，浏览器立即进行下载<br>
<!-- -->同时继续加载界面，等到html解析完毕后执行脚本  </p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="兼容性">兼容性<a href="#兼容性" class="hash-link" aria-label="兼容性的直接链接" title="兼容性的直接链接">​</a></h4><p>假如浏览器无法兼容这两个属性可以选择把script标签放在页面底部</p>]]></content:encoded>
            <category>JavaScript</category>
            <category>问题回顾</category>
        </item>
        <item>
            <title><![CDATA[粘性定位失效的问题]]></title>
            <link>https://qym994.github.io/qym-vue-5</link>
            <guid>https://qym994.github.io/qym-vue-5</guid>
            <pubDate>Tue, 07 Mar 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[粘滞定位失效的问题]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="粘滞定位失效的问题">粘滞定位失效的问题<a href="#粘滞定位失效的问题" class="hash-link" aria-label="粘滞定位失效的问题的直接链接" title="粘滞定位失效的问题的直接链接">​</a></h3><p>写项目时发现batterscroll里的粘滞定位失效了
batterscroll使用时需设置父元素overflow：hidden影响了粘性定位</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="粘性定位的原理">粘性定位的原理<a href="#粘性定位的原理" class="hash-link" aria-label="粘性定位的原理的直接链接" title="粘性定位的原理的直接链接">​</a></h3><p>Sticky（当它表现为 fixed 定位的特性时）会根据最近的滚动容器（nearest scrollport）自动计算偏移量。
其中有一个非常重要的概念就是 nearest scrollport，它表示 sticky 元素在即将消失前会相对它最近的 scrollport 去做定位。
须指定top, right, bottom 或 left 四个阈值其中之一（且达到设定的阈值），才可使粘性定位生效。否则其行为与相对定位相同；</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="粘性定位失效的情况">粘性定位失效的情况<a href="#粘性定位失效的情况" class="hash-link" aria-label="粘性定位失效的情况的直接链接" title="粘性定位失效的情况的直接链接">​</a></h3><ol><li>包裹的父容器高度与sticky元素一致</li><li>包裹的父容器设置了overflow为非visible</li><li>没有指定top, right, bottom 或 left</li></ol>]]></content:encoded>
            <category>Vue</category>
            <category>问题回顾</category>
        </item>
        <item>
            <title><![CDATA[箭头函数和普通函数区别]]></title>
            <link>https://qym994.github.io/qym-js-6</link>
            <guid>https://qym994.github.io/qym-js-6</guid>
            <pubDate>Wed, 01 Mar 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[箭头函数和普通函数的区别]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="箭头函数和普通函数的区别">箭头函数和普通函数的区别<a href="#箭头函数和普通函数的区别" class="hash-link" aria-label="箭头函数和普通函数的区别的直接链接" title="箭头函数和普通函数的区别的直接链接">​</a></h3><ol><li>箭头函数在创建时不会有'Construct'方法，没有构造能力，无proptotype属性</li><li>箭头函数没有'arguments'对象，和第一点都是不需要复用的原因</li><li>this的指向  </li></ol><ul><li>普通函数的this是动态的，是实际执行的时候确认的  <ul><li>以函数形式调用 this =&gt; window对象</li><li>以方法形式调用 this =&gt; 调用方法的对象</li><li>构造函数中 this =&gt; 新创建的对象</li></ul></li><li>箭头函数的this在创建的时候固定为外部函数的this</li><li>顺便复习一下this指向的改变方法(箭头函数无法更改)<ul><li>call 调用方式<code>fn.call(xxx)</code>传入的第一个参数会变成fn的this指向，后续的参数作为实参传入</li><li>apply 调用方式<code>fn.apply(xxx)</code>传入的第一个参数会变成fn的this指向，后续的参数使用数据作为实参传入</li><li>bind  调用方式<code>const newfn() = fn.bind(xxx)</code>传入的第一个参数会变成newfn的this指向,后续的参数会绑定给newfn的实参</li></ul></li></ul>]]></content:encoded>
            <category>JavaScript</category>
            <category>问题回顾</category>
        </item>
        <item>
            <title><![CDATA[vant轻提示不生效]]></title>
            <link>https://qym994.github.io/qym-vue-4</link>
            <guid>https://qym994.github.io/qym-vue-4</guid>
            <pubDate>Mon, 20 Feb 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[vant轻提示不生效]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="vant轻提示不生效">vant轻提示不生效<a href="#vant轻提示不生效" class="hash-link" aria-label="vant轻提示不生效的直接链接" title="vant轻提示不生效的直接链接">​</a></h3><p>Vant 中有个别组件是以函数的形式提供的<br>
<!-- -->包括 Toast，Dialog，Notify 和 ImagePreview 组件<br>
<!-- -->在使用函数组件时，unplugin-vue-components 无法自动引入对应的样式，因此需要手动引入样式<br>
<!-- -->引入Notify组件<code>import 'vant/es/notify/style'</code><br>
<!-- -->引入Toast组件<code>import 'vant/es/toast/style'</code></p>]]></content:encoded>
            <category>Vue</category>
            <category>问题回顾</category>
            <category>vant</category>
        </item>
        <item>
            <title><![CDATA[vue3深层代理]]></title>
            <link>https://qym994.github.io/qym-vue-3</link>
            <guid>https://qym994.github.io/qym-vue-3</guid>
            <pubDate>Sun, 12 Feb 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[vue3深层代理]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="vue3深层代理">vue3深层代理<a href="#vue3深层代理" class="hash-link" aria-label="vue3深层代理的直接链接" title="vue3深层代理的直接链接">​</a></h3><p>为啥发现这个问题是我在做项目时发现vant引入的Form表单失去焦点自动提交<br>
<!-- -->原因是没有声明变量接受变量，但在setup语法糖中出现了问题：用数组接收表单数据报错<br>
<!-- -->校验发现必须单独申明v-model也就是表单input中的每一个变量<br>
<!-- -->错以为是reactive的代理是浅层的<br>
<!-- -->只能舍弃语法糖写法，在setup()函数中声明，最后return{...toRefs(userinfo)}
reactive()返回的是一个对象的深层代理<br>
<!-- -->shallowReactive()创建的是一个对象的浅层代理</p>]]></content:encoded>
            <category>Vue</category>
            <category>问题回顾</category>
            <category>vant</category>
        </item>
        <item>
            <title><![CDATA[响应式原理]]></title>
            <link>https://qym994.github.io/qym-vue-2</link>
            <guid>https://qym994.github.io/qym-vue-2</guid>
            <pubDate>Tue, 07 Feb 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[响应式原理]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="响应式原理">响应式原理<a href="#响应式原理" class="hash-link" aria-label="响应式原理的直接链接" title="响应式原理的直接链接">​</a></h3><p>只有被vue代理的对象才是响应式的，vue3中使用代理模式完成对象的响应式改造<br>
<!-- -->响应式数据可以通过组件实例直接访问<br>
<!-- -->普通对象在被修改时不会触发元素的重新渲染  </p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const obj={name:qym}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//handler用来指定代理的行为</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const handler = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    get(target,prop,recevier){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //target:被代理的对象 prop读取的属性 recevier代理对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return target[prop]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        track()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    set(target,prop,recevier.value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //前三个参数同上，value是修改的属性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    target[prop] = value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    trigger()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const proxy = new Proxy(obj,handler) //创建代理对象 </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码中核心是track方法和trigger方法<br>
<strong>track：在vue代理读取属性时会先进行追踪，记录使用该值的位置<br>trigger: 修改被代理的值后，触发所有track记录的位置进行更新</strong></p>]]></content:encoded>
            <category>Vue</category>
            <category>问题回顾</category>
        </item>
        <item>
            <title><![CDATA[通过 url 传递参数控制页面显示数据的两种方式]]></title>
            <link>https://qym994.github.io/qym-node.js-1</link>
            <guid>https://qym994.github.io/qym-node.js-1</guid>
            <pubDate>Fri, 03 Feb 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[通过 url 传递参数控制页面显示数据的两种方式]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="通过-url-传递参数控制页面显示数据的两种方式">通过 url 传递参数控制页面显示数据的两种方式<a href="#通过-url-传递参数控制页面显示数据的两种方式" class="hash-link" aria-label="通过 url 传递参数控制页面显示数据的两种方式的直接链接" title="通过 url 传递参数控制页面显示数据的两种方式的直接链接">​</a></h3><ol><li>query查询字符串传参
get请求默认通过查询字符串传递参数，服务器端以<code>/xxx?y=z</code>的形式接受"参数</li><li>param传参
get请求可以以param的形式传参<code>/xxx/:y</code><br><strong>query 传参配置的是path，而params传参配置的是name，query传递的参数会显示在地址栏中</strong><strong>query在路由配置不需要设置参数，而params必须设置(指定"：y")</strong></li><li>二者思想区别
约定优于配置：query传递参数需要指定属性名，param在配置路由时已经指定完毕<br>换句话说query需要配置属性名，而param已经约定好了传参时不用再配置</li></ol>]]></content:encoded>
            <category>Node.Js</category>
            <category>问题回顾</category>
        </item>
        <item>
            <title><![CDATA[在外部的js文件中使用pinia store中的数据报错未挂载pinia]]></title>
            <link>https://qym994.github.io/qym-vue-1</link>
            <guid>https://qym994.github.io/qym-vue-1</guid>
            <pubDate>Sat, 28 Jan 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[在外部的js文件中使用pinia store中的数据报错未挂载pinia]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="在外部的js文件中使用pinia-store中的数据报错未挂载pinia">在外部的js文件中使用pinia store中的数据报错未挂载pinia<a href="#在外部的js文件中使用pinia-store中的数据报错未挂载pinia" class="hash-link" aria-label="在外部的js文件中使用pinia store中的数据报错未挂载pinia的直接链接" title="在外部的js文件中使用pinia store中的数据报错未挂载pinia的直接链接">​</a></h3><p>写路由时需要用到store里的用户登录状态,报错为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">`Error: [🍍]: getActivePinia was called with no active Pinia. Did you forget to install pinia?  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const pinia = createPinia()  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">app.use(pinia)`</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>解决方法创建store时，导出pinia实例 </p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">import { createPinia } from 'pinia';</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const pinia = createPinia()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">export default pinia</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在使用时传递pinia实例  </p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">import pinia from "../store/user"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import { useUserStore } from "../store/user";</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const store = useUserStore(pinia)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>Vue</category>
            <category>问题回顾</category>
            <category>pinia</category>
        </item>
        <item>
            <title><![CDATA[可变参数]]></title>
            <link>https://qym994.github.io/qym-js-5</link>
            <guid>https://qym994.github.io/qym-js-5</guid>
            <pubDate>Sat, 21 Jan 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[arguments]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="arguments">arguments<a href="#arguments" class="hash-link" aria-label="arguments的直接链接" title="arguments的直接链接">​</a></h3><p>arguments是函数中的隐含参数，是一个伪数组对象，用来存储函数的实参<br>
<!-- -->无论用户是否定义形参，实参都会存到arguments对象中，可以通过索引读取实参  </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="可变参数">可变参数<a href="#可变参数" class="hash-link" aria-label="可变参数的直接链接" title="可变参数的直接链接">​</a></h3><p>可变参数<code>...args</code>在定义函数时将参数指定为可变参数<br>
<!-- -->可变参数<code>args</code>是一个数组可以使用数组的方法，可以命名，也可以配合其他参数</p>]]></content:encoded>
            <category>JavaScript</category>
            <category>问题回顾</category>
        </item>
        <item>
            <title><![CDATA[事件传播]]></title>
            <link>https://qym994.github.io/qym-js-4</link>
            <guid>https://qym994.github.io/qym-js-4</guid>
            <pubDate>Sun, 15 Jan 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[事件对象event]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="事件对象event">事件对象event<a href="#事件对象event" class="hash-link" aria-label="事件对象event的直接链接" title="事件对象event的直接链接">​</a></h3><p>事件对象是浏览器在事件触发时创建的对象，其中封装了事件相关的各种信息<br>
<!-- -->在事件的回调函数中定义一个形参接受事件对象，例如：<br>
<code>const box.onmousemove = function(event){this/event.target}</code>    </p><ul><li>在事件的响应函数中<code>event.target</code>表示触发事件的对象</li><li><code>this</code>表示绑定事件的对象  </li><li><code>event.stopPropagation()</code> 取消事件传导  </li><li><code>event.preventDefault</code>取消默认行为，例如取消表单提交，超链接跳转</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="事件的传播机制">事件的传播机制<a href="#事件的传播机制" class="hash-link" aria-label="事件的传播机制的直接链接" title="事件的传播机制的直接链接">​</a></h3><p>DOM中事件传播分为三个阶段：1.捕获阶段 2.目标阶段 3.冒泡阶段 </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="事件的冒泡bubble">事件的冒泡(bubble)<a href="#事件的冒泡bubble" class="hash-link" aria-label="事件的冒泡(bubble)的直接链接" title="事件的冒泡(bubble)的直接链接">​</a></h3><p>事件的冒泡就是指事件的向上传导</p><ul><li>当元素上的事件触发时，其祖先元素的相同事件也会触发 后代触发=&gt;父类触发=&gt;祖先触发  </li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="事件的委派">事件的委派<a href="#事件的委派" class="hash-link" aria-label="事件的委派的直接链接" title="事件的委派的直接链接">​</a></h3><p>本该绑定给多个元素的事件，统一绑定给document，由于事件的冒泡，所有的document中的元素都会触发事件
这样可以降低代码复杂度维护，利用<code>event.target</code>做触发判断就可以了<br>
<!-- -->给 父元素注册事件 ，当我们触发子元素的时候，会冒泡到父元素身上，从而触发父元素的事件</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="事件的捕获">事件的捕获<a href="#事件的捕获" class="hash-link" aria-label="事件的捕获的直接链接" title="事件的捕获的直接链接">​</a></h3><p>事件由外到内的传播，事件触发后会从当前元素最大的祖先元素开始向当前元素进行事件捕获
如果希望在捕获阶段触发事件将<code>addEventListener</code>的第三个参数设置为true</p>]]></content:encoded>
            <category>JavaScript</category>
            <category>问题回顾</category>
        </item>
        <item>
            <title><![CDATA[常用的数组方法]]></title>
            <link>https://qym994.github.io/qym-js-3</link>
            <guid>https://qym994.github.io/qym-js-3</guid>
            <pubDate>Wed, 11 Jan 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[常用的数组方法]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="常用的数组方法">常用的数组方法<a href="#常用的数组方法" class="hash-link" aria-label="常用的数组方法的直接链接" title="常用的数组方法的直接链接">​</a></h3><ol><li><code>Array.push()</code>将传入的参数追加到原数组的末尾，push方法可传多个参数和单个参数  </li></ol><ul><li><strong>如果传入另一个数组将不会拆分，会作为整体即一个子元素传入(可用...展开数组)</strong></li></ul><ol start="2"><li><code>Array.forEach((item,index,thisArr)=&gt;{})</code></li></ol><ul><li>item当前遍历到的元素，index遍历到的元素索引，thisArr表示当前数组
3.<code>Array.map((item,index,thisArr)=&gt;{retrun xxx})</code>  </li><li>参数同上 <strong>xxx表示对数组的处理</strong><br>4.<code>Array.filter((item,index,thisArr)=&gt;{retrun xxx})</code>  </li><li>参数同上 <strong>xxx表示过滤的条件(判断语句)</strong><br>5.<code>Array.splice()</code>  </li><li>传入两个参数时进行删除，第一个参数是开始删除的索引，第二个参数是删除的元素个数</li><li>传入三个参数时进行修改，第一个参数是插入的索引，第二个参数修改的元素个数，第三个参数是修改的元素</li></ul>]]></content:encoded>
            <category>JavaScript</category>
            <category>问题回顾</category>
        </item>
        <item>
            <title><![CDATA[Esmodule和Commonjs规范]]></title>
            <link>https://qym994.github.io/qym-js-2</link>
            <guid>https://qym994.github.io/qym-js-2</guid>
            <pubDate>Sat, 07 Jan 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Esmodule和Commonjs规范]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="esmodule和commonjs规范">Esmodule和Commonjs规范<a href="#esmodule和commonjs规范" class="hash-link" aria-label="Esmodule和Commonjs规范的直接链接" title="Esmodule和Commonjs规范的直接链接">​</a></h3><p>commonjs和esmodule是目前前端主要的模块化方案</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="commonjs">Commonjs<a href="#commonjs" class="hash-link" aria-label="Commonjs的直接链接" title="Commonjs的直接链接">​</a></h4><p>commonjs也叫cjs,在node中每一个js文件都是一个单独的模块<br>
<!-- -->这个模块中包含CommonJS的规范的核心变量: <strong>exports， module.exports, require</strong><br>
<!-- -->exports和module.exports可以负责对模块中的内容进行导出    </p><ul><li>exports和module.exports本来指向的是同一个引用地址，但是真正导入的是module.exports   </li><li>require函数可以帮助我们导入其他模块（自定义模块，系统模块，第三方库）<br><strong>注意</strong>  commonjs加载是同步的，所以必须等到相应的模块加载完毕，才执行后续代码<br>在浏览器环境中同步请求资源可能会引起卡顿<br>加载模块的时候，每一个模块上会有一个 loaded 布尔值属性避免重复加载  </li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="esmodule">Esmodule<a href="#esmodule" class="hash-link" aria-label="Esmodule的直接链接" title="Esmodule的直接链接">​</a></h4><p>ES Module 使用 import导入 和 export导出</p><ul><li>默认导出的情况下可以不指定名字，引入也可以不使用"{}"并自己命名
<strong>使用 ES Module 将会自动开启严格模式</strong></li></ul>]]></content:encoded>
            <category>模块化</category>
            <category>问题回顾</category>
            <category>Node.js</category>
        </item>
        <item>
            <title><![CDATA[正则表达式]]></title>
            <link>https://qym994.github.io/qym-js-1</link>
            <guid>https://qym994.github.io/qym-js-1</guid>
            <pubDate>Sun, 01 Jan 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[正则表达式]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="正则表达式">正则表达式<a href="#正则表达式" class="hash-link" aria-label="正则表达式的直接链接" title="正则表达式的直接链接">​</a></h3><p>写项目的时候遇到了表单验证的问题，即确定用户的提交内容是否合法<br>
<!-- -->问题在于用户名，密码以及邮箱的格式是否合规</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1-定义">1. 定义<a href="#1-定义" class="hash-link" aria-label="1. 定义的直接链接" title="1. 定义的直接链接">​</a></h4><blockquote><p>正则表达式是一个规则<br>
<!-- -->通过这个规则计算机可以检查一个字符串是否符合规则  </p></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="2-创建方式">2. 创建方式<a href="#2-创建方式" class="hash-link" aria-label="2. 创建方式的直接链接" title="2. 创建方式的直接链接">​</a></h4><blockquote><p>通过构造函数创建：
<code>let reg = new RegExp("reg","model")</code><br>
<!-- -->reg是正则本身，model是匹配模式<br>
<!-- -->通过字面量创建：
<code>reg = /reg/model</code><br>
<!-- -->参数意义同上<br>
<strong>注意</strong>：构造函数可以用变量指定正则(reg)<br>
<!-- -->转义字符<code>\</code>在函数中会自动转义一次，如需限制字符"\"要写为<code>\\</code>  </p></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="3使用">3.使用<a href="#3使用" class="hash-link" aria-label="3.使用的直接链接" title="3.使用的直接链接">​</a></h4><blockquote><ul><li>最常用的用法"匹配" ：<code>let result = reg.test(str)</code><br>str是待测项目 reg是正则表达式 result是返回的结果(布尔值)  </li><li>过滤:<code>let result = reg.exec(str)</code>提取出str中符合正则表达式的内容
<strong>注意</strong>result的结构为<code>['a','b',index:number,input:string,groups:undefined]</code>
a是符合匹配规则的整体,b是分组内容即"()"里的内容"可有多个b,index表示a在整个result中的序号,input表示输入的str
groups表示具名匹配,允许为每一个组匹配指定一个名字 ,在组中用<code>&lt;&gt;</code>命名</li></ul></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="4reg常用语法">4."reg"常用语法<a href="#4reg常用语法" class="hash-link" aria-label="4.&quot;reg&quot;常用语法的直接链接" title="4.&quot;reg&quot;常用语法的直接链接">​</a></h4><blockquote><ol><li><code>|</code> 表示或</li><li><code>[]</code> 表示字符集</li></ol><ul><li><code>[a-z]</code>表示小写字母a到z</li><li><code>[A-Z]</code>表示大写字母A到Z</li><li><code>[a-zA-Z]</code>表示任意字母  </li></ul><ol start="3"><li><code>[^]</code>表示字符集取反,例如<code>reg=/[^x]/</code>即除了x之外任意字符串</li><li><code>.</code>表示除了换行"\"以外的任意字符串,如需检查"."使用<code>\.</code></li><li><code>^</code>表示字符串开头</li><li><code>$</code>表示表示字符串结尾 <strong>注意</strong><code>^</code>和<code>$</code>常与其他正则组合使用,例如<code>/^x$/</code>表示只匹配x(完全匹配)</li><li>常用字符集  </li></ol><ul><li><code>/w</code>表示基本拉丁字母中的任意字母数字字符,包括下划线,即<code>/[a-zA-z0-9_]</code></li><li><code>/W</code>表示<code>/w</code>取反,即<code>/[^a-zA-z0-9_]</code></li><li><code>/d</code>表示数字,即<code>[0-9]</code></li><li><code>/D</code>表示<code>/d</code>取反,即<code>[^0-9]</code></li></ul><ol start="8"><li>量词</li></ol><ul><li><code>{m}</code>表示恰好m个只对前面的字符使用,可使用"()"进行量词分组<br>例如<code>/a{3}/</code>匹配"aaa",<code>/(ab){3}/</code>匹配"ababab"</li><li><code>{m,n}</code>表示m到n个之间</li><li><code>{m,}</code>表示至少m个</li><li><code>{+}</code>表示至少一个,即<code>{1,}</code></li><li><code>*</code>表示任意数量,即有不报错多了也可以</li><li><code>?</code>表示0或者1茨,即<code>{0,1}</code></li></ul></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="5model匹配模式">5."model"匹配模式<a href="#5model匹配模式" class="hash-link" aria-label="5.&quot;model&quot;匹配模式的直接链接" title="5.&quot;model&quot;匹配模式的直接链接">​</a></h4><blockquote><ol><li><code>i</code>表示忽略大小写,例如<code>/[a-z]/i</code></li><li><code>g</code>表示全局匹配.默认正则表达式只匹配第一个符合条件的字符串,找到即终止  </li></ol></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="6常用正则表达式">6.常用正则表达式<a href="#6常用正则表达式" class="hash-link" aria-label="6.常用正则表达式的直接链接" title="6.常用正则表达式的直接链接">​</a></h4><blockquote><ol><li>用户名正则，4到16位（字母，数字，下划线，减号）<br><code>let uPattern = /^[a-zA-Z0-9_-]{4,16}$/</code></li><li>//密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字<br><code>let pPattern = /^.*(?=.{6,})(?=.*\d)(?=.*[A-Z])(?=.*[a-z]).*$/</code>  </li><li>//Email正则<br><code>let ePattern = /^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]{2,4})$/</code></li></ol></blockquote>]]></content:encoded>
            <category>JavaScript</category>
            <category>问题回顾</category>
        </item>
        <item>
            <title><![CDATA[原型链]]></title>
            <link>https://qym994.github.io/auditon-26</link>
            <guid>https://qym994.github.io/auditon-26</guid>
            <pubDate>Thu, 03 May 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[原型链]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="原型链">原型链<a href="#原型链" class="hash-link" aria-label="原型链的直接链接" title="原型链的直接链接">​</a></h3>]]></content:encoded>
            <category>面试准备</category>
            <category>Javascript</category>
        </item>
        <item>
            <title><![CDATA[防抖和节流]]></title>
            <link>https://qym994.github.io/auditon-25</link>
            <guid>https://qym994.github.io/auditon-25</guid>
            <pubDate>Wed, 02 May 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[防抖和节流]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="防抖和节流">防抖和节流<a href="#防抖和节流" class="hash-link" aria-label="防抖和节流的直接链接" title="防抖和节流的直接链接">​</a></h3>]]></content:encoded>
            <category>面试准备</category>
            <category>Javascript</category>
        </item>
        <item>
            <title><![CDATA[闭包]]></title>
            <link>https://qym994.github.io/auditon-20</link>
            <guid>https://qym994.github.io/auditon-20</guid>
            <pubDate>Tue, 01 May 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[词法作用域]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="词法作用域">词法作用域<a href="#词法作用域" class="hash-link" aria-label="词法作用域的直接链接" title="词法作用域的直接链接">​</a></h3><p>函数的作用域在创建时已经确定，与调用位置无关</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="闭包模板">闭包模板？<a href="#闭包模板" class="hash-link" aria-label="闭包模板？的直接链接" title="闭包模板？的直接链接">​</a></h3><p>  function outer(){
let count = 0
return function inner(){
count++
}
}</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="闭包的生命周期">闭包的生命周期<a href="#闭包的生命周期" class="hash-link" aria-label="闭包的生命周期的直接链接" title="闭包的生命周期的直接链接">​</a></h3><ol><li>闭包在外部函数时调用，外部函数每次调用都会产生一个全新的闭包</li><li>在内部函数丢失时销毁(垃圾回收)</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="闭包注意事项">闭包注意事项<a href="#闭包注意事项" class="hash-link" aria-label="闭包注意事项的直接链接" title="闭包注意事项的直接链接">​</a></h3><p>闭包主要用来隐藏一些不想被外部访问的内容，意味着需要一定的内存空间<br>
<!-- -->相较于类来说，闭包比较浪费内存空间(类可以使用原型而闭包不能)</p>]]></content:encoded>
            <category>面试准备</category>
            <category>Javascript</category>
        </item>
        <item>
            <title><![CDATA[jwt]]></title>
            <link>https://qym994.github.io/auditon-19</link>
            <guid>https://qym994.github.io/auditon-19</guid>
            <pubDate>Wed, 04 Apr 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[jsonwebtoken]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="jsonwebtoken">jsonwebtoken<a href="#jsonwebtoken" class="hash-link" aria-label="jsonwebtoken的直接链接" title="jsonwebtoken的直接链接">​</a></h3><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const jwt = require("jsonwebtoken")</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const token = jwt.sign(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //传入三个参数：1.负载 2.加密密钥 3.配置对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    配置对象中：expiresIn属性设置过期时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//服务器收到客户端的token后</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">try{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const decodeData = jwt.verify(token,"加密密匙")}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">catch(err){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>面试准备</category>
            <category>Nodejs</category>
        </item>
        <item>
            <title><![CDATA[CORS(跨域资源共享)]]></title>
            <link>https://qym994.github.io/auditon-18</link>
            <guid>https://qym994.github.io/auditon-18</guid>
            <pubDate>Tue, 03 Apr 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[CORS]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="cors">CORS<a href="#cors" class="hash-link" aria-label="CORS的直接链接" title="CORS的直接链接">​</a></h3><p>跨域请求：如果两个网站的完整域名不相同<br>
<!-- -->协议，域名，端口号都必须全部相同<br>
<!-- -->浏览器会自动阻止数据的读取  </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="解决方法">解决方法<a href="#解决方法" class="hash-link" aria-label="解决方法的直接链接" title="解决方法的直接链接">​</a></h3><p>在服务器中设置一个允许跨域的头：Access-Control-Allow-Origin<br>
<!-- -->在路由中：<code>res.setHeader('Access-Control-Allow-Origin','允许的路径')</code><br>
<!-- -->setHeader参数：</p><ol><li>Access-Control-Allow-Origin：设置指定值时只能设置一个  </li><li>Access-Control-Allow-Methods：允许的请求方式</li><li>Access-Control-Allow-Headers：允许传递的请求头</li></ol>]]></content:encoded>
            <category>面试准备</category>
            <category>Nodejs</category>
        </item>
        <item>
            <title><![CDATA[AJAX]]></title>
            <link>https://qym994.github.io/auditon-17</link>
            <guid>https://qym994.github.io/auditon-17</guid>
            <pubDate>Mon, 02 Apr 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[AJAX]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="ajax">AJAX<a href="#ajax" class="hash-link" aria-label="AJAX的直接链接" title="AJAX的直接链接">​</a></h3><p>A：异步 J：js A：和 X：XML AJAX：异步的js和xml<br>
<!-- -->可选方案</p><ol><li>XMLHTTPRequest(xhr)</li></ol><ul><li>xhr写法：  <!-- -->  const xhr = new XMLHttpRequest()
//设置请求信息
xhr.open("GET","http://xxx")
//发送请求
xhr.send()
</li></ul><ol start="2"><li>Fetch</li></ol><ul><li>fetch是xml的升级版，采用的Promise API且js原生支持<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//终止请求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const controller = new AbortController()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">btn.onclick = ()=&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    controller &amp;&amp; constroller.abort()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fetch("http://xxx","{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//配置对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">signal:controller.signal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">method:"请求方式",</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">headers:"{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    "authorization":`Bearer ${token}`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    "Content-Type":"application/json"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //"Content-Type":"application/x-www-from-urlencoded"表单项</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //需要在Access-Control-Allow-Headers中设置Content-Type，authorization</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    body：JSON.stringfiy("请求内容")</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}"})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.then((res)=&gt;{})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.catch((err)=&gt;{})</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>可以选择在then中抛出错误给catch处理<br>用await改写时使用try-catch</li></ul><ol start="3"><li>Axios
使用方法：<code>axios({config//配置对象})</code><br>别名：<code>axios.get(url[,config]),axios.post(url[,data,config])</code><br>和fetch的区别：</li><li>不需要设置Content-Type会自动设置</li><li>读取数据时，不需要再进行json格式转换</li><li>不再是返回响应就执行then，而是响应状态码为2xx时才执行<br>配置对象<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">axios{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    url："http://xxx"(必选项)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //指定服务器根目录</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    baseURL:http://xxx</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //请求方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    method:"GET/..."</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //请求头</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    headers：{"authorization":`Bearer ${token}`"}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //请求体</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    data：{}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //处理请求数据data，需要传入一个数组，数据接收多个函数并按顺序执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //默认接收两个参数data和headers</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //最后一个函数必须返回字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    transformRequest[function(data,headers)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //处理响应数据data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    transformResult[function(data,headers)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //指定路径中的查询字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params:{}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //指定超时时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    timeout：xxx</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //终止请求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    signal:和fetch相投相同</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li></ol><p>}
4. axios响应的结构</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //服务器的响应</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    data{}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //响应状态码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    status:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //响应信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    statusText：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //响应头且全是小写</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    headers:{}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 请求信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    config:{}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //原生的xhr对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    request:{}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol start="5"><li>默认配置
<code>axios.defaults.baseURL = ""</code><code>axios.defaults.common["Authorization"]="Bearer ${localStorage.getItem("token")}"</code>  </li><li>axios实例
<code>const instance = axios.create()</code>作用与axios本身相同，结合默认设置使用</li><li>axios拦截器
<code>axios.interceptors.request.use(function(config){})</code><br>请求拦截在请求发出前处理
<code>axios.interceptors.response.use(function(config){})</code><br>在接收响应前处理</li></ol>]]></content:encoded>
            <category>面试准备</category>
            <category>Nodejs</category>
        </item>
        <item>
            <title><![CDATA[REST风格的服务器]]></title>
            <link>https://qym994.github.io/auditon-16</link>
            <guid>https://qym994.github.io/auditon-16</guid>
            <pubDate>Sun, 01 Apr 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[传统的MVC模式服务器]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="传统的mvc模式服务器">传统的MVC模式服务器<a href="#传统的mvc模式服务器" class="hash-link" aria-label="传统的MVC模式服务器的直接链接" title="传统的MVC模式服务器的直接链接">​</a></h3><p>Model -- 数据模型<br>
<!-- -->View -- 视图<br>
<!-- -->Controller -- 控制器，加载复杂数据并选择视图来呈现数据<br>
<!-- -->传统的服务器直接为客户端返回一个页面  </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="存在的问题">存在的问题<a href="#存在的问题" class="hash-link" aria-label="存在的问题的直接链接" title="存在的问题的直接链接">​</a></h3><p>一个应用需要服务多个客户端(PC，移动端，web端)<br>
<!-- -->服务器返回页面时过于繁琐<br>
<strong>前后端分离后</strong>，服务器只提供数据，一个服务器可以为多种客户端服务<br>
<!-- -->渲染的工作由客户端完成  </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="rest风格的服务器">REST风格的服务器<a href="#rest风格的服务器" class="hash-link" aria-label="REST风格的服务器的直接链接" title="REST风格的服务器的直接链接">​</a></h3><p>REST即Representational State Transfer表示层的传输<br>
<!-- -->特点是只返回数据，服务器与客户端之间通信常使用JSON格式<br>
<!-- -->请求的方法：  </p><table><thead><tr><th>请求方式</th><th>请求内容</th></tr></thead><tbody><tr><td>GET</td><td>加载数据</td></tr><tr><td>POST</td><td>新建或添加数据</td></tr><tr><td>PUT</td><td>添加或修改数据</td></tr><tr><td>PATCH</td><td>修改数据</td></tr><tr><td>DELETE</td><td>删除数据</td></tr><tr><td>OPTION</td><td>由浏览器发送检查请求权限</td></tr></tbody></table><p>格式：API(接口)/Endpoint(端点)<br>
<!-- -->例如：GET/user   DELETE/user</p>]]></content:encoded>
            <category>面试准备</category>
            <category>Nodejs</category>
        </item>
        <item>
            <title><![CDATA[移动端适配]]></title>
            <link>https://qym994.github.io/auditon-15</link>
            <guid>https://qym994.github.io/auditon-15</guid>
            <pubDate>Fri, 02 Mar 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[移动端适配]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="移动端适配">移动端适配<a href="#移动端适配" class="hash-link" aria-label="移动端适配的直接链接" title="移动端适配的直接链接">​</a></h3><ol><li>viewport适配</li></ol><ul><li>利用完美视口适配</li><li>使用插件将css像素px转为vw适配</li><li>px 转换成 vw 不一定能完全整除，因此有一定的像素差</li></ul><ol start="2"><li>媒体查询(media query):通过媒体查询为不同的屏幕大小设置样式</li></ol><ul><li>使用max-width和min-width限定样式</li><li>页面上所有的元素都得在不同的 @media 中定义一遍不同的尺寸，代价过高</li><li>如果再多一种屏幕尺寸，就得多写一个 @media 查询块</li></ul><ol start="3"><li>rem适配</li></ol><ul><li>rem是css3新增的一个相对单位。rem为相对HTML根元素的大小，默认1rem为16px</li><li>动态的计算rem就可以实现移动端适配(结合vw)</li><li>为了方便计算我们一般设置1rem=100px，我们需要设置字体大小为100px</li><li>rem/100px = 100vw/设计图尺寸</li></ul>]]></content:encoded>
            <category>面试准备</category>
            <category>Css</category>
        </item>
        <item>
            <title><![CDATA[Css]]></title>
            <link>https://qym994.github.io/auditon-14</link>
            <guid>https://qym994.github.io/auditon-14</guid>
            <pubDate>Thu, 01 Mar 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[css选择器优先级]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="css选择器优先级">css选择器优先级<a href="#css选择器优先级" class="hash-link" aria-label="css选择器优先级的直接链接" title="css选择器优先级的直接链接">​</a></h3><p>!important&gt;内联样式&gt;id&gt;类/伪类/属性&gt;标签&gt;全局</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="盒模型">盒模型<a href="#盒模型" class="hash-link" aria-label="盒模型的直接链接" title="盒模型的直接链接">​</a></h3><p>元素可以看作一个盒子：由外到内是外边距margin，边框border，内边距padding，内容content几部分组成<br>
<!-- -->可用box-sizing控制盒模型种类：默认content-box(width指的是内容区)，可改为border-box(width包括所有内容)<br>
<!-- -->水平布局等式：margin+border+padding+content = 包含块的宽度<br>
<!-- -->等式不满足时，会强制调整：</p><ol><li>若有一个值为auto则调整值为auto的值</li><li>若无auto，优先调整右外边距margin-right</li><li>若左右外边距为auto，则均分调整(水平居中原理)</li><li>当外边距和width同时设置为auto时，外边距为0</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="bfc块级格式化环境">BFC块级格式化环境<a href="#bfc块级格式化环境" class="hash-link" aria-label="BFC块级格式化环境的直接链接" title="BFC块级格式化环境的直接链接">​</a></h3><ol><li>开启浮动</li><li>overflow设置为非默认值visible</li><li>display：flow-root</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="clearfix">clearfix<a href="#clearfix" class="hash-link" aria-label="clearfix的直接链接" title="clearfix的直接链接">​</a></h3><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">.clearfix::before,.clearfix::after{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">content:"",</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">display:table,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">clear:both</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>}
解决高度塌陷和外边距重叠</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="flex布局">flex布局<a href="#flex布局" class="hash-link" aria-label="flex布局的直接链接" title="flex布局的直接链接">​</a></h3><p>给元素设置display：flex后元素成为弹性容器，子元素变为弹性元素<br>
<!-- -->flex-direction：更改主轴(弹性子元素排列的方向)<br>
<!-- -->flex-wrap：设置子元素是否换行<br>
<!-- -->justify-content:设置元素在主轴的对齐方式<br>
<!-- -->align-item:设置元素在辅轴上的对齐方式
align-content:设置元素辅轴方向的空白空间如何分配<br>
<!-- -->flex:是flex-grow(弹性元素生长系数),flex-shrink(弹性元素收缩系数),flex-basis(弹性元素基础大小)  </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="雪碧图精灵图">雪碧图/精灵图<a href="#雪碧图精灵图" class="hash-link" aria-label="雪碧图/精灵图的直接链接" title="雪碧图/精灵图的直接链接">​</a></h3><p>将多个小的图片放到一个大图中，使用background-position决定展示的小图片</p>]]></content:encoded>
            <category>面试准备</category>
            <category>Css</category>
        </item>
        <item>
            <title><![CDATA[从地址栏输入url到显示页面]]></title>
            <link>https://qym994.github.io/auditon-24</link>
            <guid>https://qym994.github.io/auditon-24</guid>
            <pubDate>Mon, 05 Feb 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[从地址栏输入url到显示页面]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="从地址栏输入url到显示页面">从地址栏输入url到显示页面<a href="#从地址栏输入url到显示页面" class="hash-link" aria-label="从地址栏输入url到显示页面的直接链接" title="从地址栏输入url到显示页面的直接链接">​</a></h3><ol><li>DNS解析，获取网站的IP地址</li><li>浏览器和服务器建立连接(tcp/ip)</li><li>向服务器发送请求(http)</li><li>服务器处理请求并返回响应(http)</li><li>浏览器渲染页面</li></ol>]]></content:encoded>
            <category>面试准备</category>
            <category>计算机网络</category>
        </item>
        <item>
            <title><![CDATA[三次握手]]></title>
            <link>https://qym994.github.io/auditon-23</link>
            <guid>https://qym994.github.io/auditon-23</guid>
            <pubDate>Sun, 04 Feb 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[三次握手]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="三次握手">三次握手<a href="#三次握手" class="hash-link" aria-label="三次握手的直接链接" title="三次握手的直接链接">​</a></h3><p>三次握手是建立TCP连接的过程，目的是在不可靠的信道上保证可靠的连接<br>
<!-- -->三次指的是通信过程中发送了三次数据包<br>
<!-- -->连接过程：SYN表示Synchronization同步，ACK表示ACKnowledgment确认,确认号表示确认号-1的数据都已经正确收到  </p><ol><li>客户端发送请求报文，请求首行中同步位SYN置1，同时随机添加seqc序号</li><li>服务器收到后SYN和ACK置1，同时随机添加序号seqs，确认号为acks=seqc+1</li><li>客户端收到后进行确认，ACK置1，序号为seqs+1,确认号ackc=seqc+1
建立连接后可用https协议进行通信</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="四次挥手">四次挥手<a href="#四次挥手" class="hash-link" aria-label="四次挥手的直接链接" title="四次挥手的直接链接">​</a></h3><p>四次挥手是指TCP的连接释放<br>
<!-- -->释放过程：FIN表示Finish结束  ACK表示ACKnowledgment确认</p><ol><li>客户端发送连接释放报文，FIN置1，随机生成序号seqc</li><li>服务器收到后返回报文，ACK置1，随机生成序号seqs，确认号seqc+1</li><li>客户端收到后进入等待状态，从客户端到服务器的连接就释放了，此时TCP处于半关闭状态，服务器还可单向传输数据给客户端,服务端发送完毕后，发送释放报文，FIN和ACK置1，重复最后一段数据的确认号seqs+1，随机生成序号seqs1</li><li>客户端接收后，ACK置1，确认号seqs1+1，序号和第二步相同seqc+1</li><li>时间等待计时器设置2MSL后释放连接</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="tcp和udp的区别">TCP和UDP的区别<a href="#tcp和udp的区别" class="hash-link" aria-label="TCP和UDP的区别的直接链接" title="TCP和UDP的区别的直接链接">​</a></h3><p>TCP：Transmission Control Protocol传输控制协议<br>
<!-- -->UDP：User Datagram Protocol用户数据报协议<br>
<!-- -->UDP是基于非连接的，面向报文，发送数据就是封装数据后由网卡发出，形式简单，性能损耗小，资源占用少，但是无法保证可靠交付，支持N对N<br>
<!-- -->TCP是基于连接的，面向连接，保证可靠交付，支持1对1全双工通信</p>]]></content:encoded>
            <category>面试准备</category>
            <category>计算机网络</category>
        </item>
        <item>
            <title><![CDATA[计算机网络的体系结构]]></title>
            <link>https://qym994.github.io/auditon-22</link>
            <guid>https://qym994.github.io/auditon-22</guid>
            <pubDate>Sat, 03 Feb 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[计算机网络的体系结构]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="计算机网络的体系结构">计算机网络的体系结构<a href="#计算机网络的体系结构" class="hash-link" aria-label="计算机网络的体系结构的直接链接" title="计算机网络的体系结构的直接链接">​</a></h3><p>计算机网络的体系结构就是计算机网络各层加上其协议的集合</p><table><tbody><tr><th colspan="3">计算机网络分层模型</th></tr><tr><td>OSI七层模型</td><td>TCP/IP四层模型</td><td>TCP/IP五层模型</td></tr><tr><td>应用层</td><td rowspan="3">应用层(DNS,HTTP等协议)</td><td rowspan="3">应用层</td></tr><tr><td>表示层</td></tr><tr><td>会话层</td></tr><tr><td>传输层</td><td>传输层(TCP/UDP)</td><td>传输层</td></tr><tr><td>网络层</td><td>网络层(IP)</td><td>网络层</td></tr><tr><td>数据链路层</td><td rowspan="2">网络接口层</td><td>数据链路层</td></tr><tr><td>物理层</td><td>物理层</td></tr></tbody></table>]]></content:encoded>
            <category>面试准备</category>
            <category>计算机网络</category>
        </item>
        <item>
            <title><![CDATA[http状态码]]></title>
            <link>https://qym994.github.io/auditon-2</link>
            <guid>https://qym994.github.io/auditon-2</guid>
            <pubDate>Fri, 02 Feb 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[http状态码]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="http状态码">http状态码<a href="#http状态码" class="hash-link" aria-label="http状态码的直接链接" title="http状态码的直接链接">​</a></h3><ol><li>定义：http状态码是服务器返回客户端的响应状态码</li><li>具体分类</li></ol><ul><li>1xx：表示通知信息，如请求收到了或正在处理</li><li><ul><li>100：Continue 客户端继续其请求</li></ul></li><li><ul><li>101：Switching Protocols 服务器切换更高级协议</li></ul></li><li>2xx：表示成功，如接受或知道了  </li><li><ul><li>200：OK 请求成功</li></ul></li><li><ul><li>201：Created 成功请求并创建资源</li></ul></li><li><ul><li>202 ：Accepted 已接受请求但还未处理</li></ul></li><li>3xx：表示重定向：如要完成请求还需要进一步行动</li><li><ul><li>301：Moved Permanently 请求的资源已经被永久移动新URI，浏览器会重新定向到新URI</li></ul></li><li><ul><li>302：Found 请求的资源临时移动，不重定向URI</li></ul></li><li>4xx：表示客户端错误，如请求中有错误的语法或不能完成</li><li><ul><li>400：Bad Request 客户端请求的语法错误</li></ul></li><li><ul><li>401：Unauthorized 客户端身份验证未通过j</li></ul></li><li><ul><li>403：Forbidden 服务器拒绝执行请求</li></ul></li><li><ul><li>404：Not Found 服务器无法找到请求的资源</li></ul></li><li>5XX：表示服务器端错误，如服务器失效</li><li><ul><li>502：Bad Gateway 错误网关</li></ul></li></ul>]]></content:encoded>
            <category>面试准备</category>
            <category>计算机网络</category>
        </item>
        <item>
            <title><![CDATA[http和https]]></title>
            <link>https://qym994.github.io/auditon-21</link>
            <guid>https://qym994.github.io/auditon-21</guid>
            <pubDate>Thu, 01 Feb 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[http和https]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="http和https">http和https<a href="#http和https" class="hash-link" aria-label="http和https的直接链接" title="http和https的直接链接">​</a></h3><p>HTTP：超文本传输协议，是客户端和服务器端请求和应答的标准,数据明文传输，是无状态的协议,默认端口80<br>
<!-- -->HTTPS:HTTPS是在HTTP上建立SSL/TLS加密层，并对传输数据进行加密，是HTTP协议的安全版，默认端口443  </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="https使用步骤">https使用步骤<a href="#https使用步骤" class="hash-link" aria-label="https使用步骤的直接链接" title="https使用步骤的直接链接">​</a></h3><ol><li>客户端使用http url访问服务器，要求web服务器建立ssl连接</li><li>web服务器接到请求后将网站的证书返回(包含了公钥)给客户端</li><li>客户端和服务器开始协商SSL连接的安全顶级</li><li>双方协商一致后，建立会话密钥，通过公钥加密密钥后发送给网站</li><li>web服务器通过自己的私钥解密出会话密钥，再用会话密钥加密和客户端的通信  </li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="https协议的优点">https协议的优点<a href="#https协议的优点" class="hash-link" aria-label="https协议的优点的直接链接" title="https协议的优点的直接链接">​</a></h3><ol><li>内容加密：采用混合加密技术，中间者无法直接查看明文内容</li><li>验证身份：通过证书认证客户端访问的是自己的服务器</li><li>保护数据完整性：防止传输的内容被中间人冒充或者篡改</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="https协议的缺点">https协议的缺点<a href="#https协议的缺点" class="hash-link" aria-label="https协议的缺点的直接链接" title="https协议的缺点的直接链接">​</a></h3><ol><li>握手比较费时</li><li>缓存不如http高效</li><li>ssl证书花费更高</li></ol>]]></content:encoded>
            <category>面试准备</category>
            <category>计算机网络</category>
        </item>
        <item>
            <title><![CDATA[网页的渲染]]></title>
            <link>https://qym994.github.io/auditon-27</link>
            <guid>https://qym994.github.io/auditon-27</guid>
            <pubDate>Sun, 14 Jan 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[网页的渲染]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="网页的渲染">网页的渲染<a href="#网页的渲染" class="hash-link" aria-label="网页的渲染的直接链接" title="网页的渲染的直接链接">​</a></h3>]]></content:encoded>
            <category>面试准备</category>
            <category>Vue</category>
        </item>
        <item>
            <title><![CDATA[如何拓展一个vue组件]]></title>
            <link>https://qym994.github.io/auditon-13</link>
            <guid>https://qym994.github.io/auditon-13</guid>
            <pubDate>Sat, 13 Jan 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[如何拓展一个vue组件]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何拓展一个vue组件">如何拓展一个vue组件<a href="#如何拓展一个vue组件" class="hash-link" aria-label="如何拓展一个vue组件的直接链接" title="如何拓展一个vue组件的直接链接">​</a></h3><ol><li>slot插槽作为内容拓展</li></ol><ul><li>父组件中在标签体中使用<code>&lt;子组件&gt;插槽内容&lt;/子组件&gt;</code></li><li>子组件在模板中使用<code>&lt;slot&gt;&lt;/slot&gt;</code></li><li>命名插槽</li><li><ul><li>则再子组件里使用<code>&lt;slot name = "xxx"&gt;&lt;/slot&gt;</code></li></ul></li><li><ul><li>父组件中使用v-slot属性对应，可简写为#<code>&lt;template #xxx&gt;</code></li></ul></li></ul><ol start="2"><li>选项式API引用可复用的函数，或者直接添加逻辑</li></ol>]]></content:encoded>
            <category>面试准备</category>
            <category>Vue</category>
        </item>
        <item>
            <title><![CDATA[vue生命周期]]></title>
            <link>https://qym994.github.io/auditon-12</link>
            <guid>https://qym994.github.io/auditon-12</guid>
            <pubDate>Fri, 12 Jan 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[vue生命周期]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="vue生命周期">vue生命周期<a href="#vue生命周期" class="hash-link" aria-label="vue生命周期的直接链接" title="vue生命周期的直接链接">​</a></h3><ol><li>定义：vue从创建到销毁的过程，在某些特定阶段用户需要添加自己的代码</li><li>vue的生命周期一共分为8个阶段：创建前后，挂载前后，更新前后和卸载前后</li><li>尝试创建组件时，一个新的生命周期就开始了</li></ol><ul><li>最早发生的是setup()函数</li><li><strong>beforeCreate：通常用于插件开发的初始化任务</strong></li><li>初始化选项式API</li><li><strong>created：组件初始化完毕，可以访问各种数据和接口数据</strong></li><li>判断是否有预编译的模板，如果有则继续，如果没有则实时编译模板得到渲染函数</li><li>beforeMount</li><li>创建并插入DOM节点</li><li><strong>mounted：DOM已经创建，可以用于获取访问数据和DOM元素，子组件等</strong></li><li>vue会不断监听响应式数据，发生变化后beforeUpdate(此时view即视图还没更新，可用于获取更新前的状态)会重新渲染，然后patch</li><li>Updated：完成view即视图的更新，更新后所有状态都是最新</li><li><strong>组件不被需要后beforeUnmounted：实例销毁前被调用，可以用于定时器，订阅的取消</strong></li><li><strong>Unmounted：销毁一个实例，清理他与其他实例的连接，解绑全部指令和事件监听器</strong></li></ul>]]></content:encoded>
            <category>面试准备</category>
            <category>Vue</category>
        </item>
        <item>
            <title><![CDATA[从template到render发生了什么]]></title>
            <link>https://qym994.github.io/auditon-11</link>
            <guid>https://qym994.github.io/auditon-11</guid>
            <pubDate>Thu, 11 Jan 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[从template到render发生了什么]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="从template到render发生了什么">从template到render发生了什么<a href="#从template到render发生了什么" class="hash-link" aria-label="从template到render发生了什么的直接链接" title="从template到render发生了什么的直接链接">​</a></h3><ol><li>vue中有独特的编译器模块compiler，负责将用户编写的template转化为渲染函数</li><li>这个编译过程能使程序员用HTML编写视图，并且享有编译期优化(patchflag)</li><li>在vue中编译器先对template进行解析，这一步成为parse，最后得到一个js对象即抽象语法树AST(类似于虚拟DOM描述视图)，然后对AST进行深加工的转换但不会产生新的东西，称为transform，最终将深加工后的AST生成渲染函数</li></ol>]]></content:encoded>
            <category>面试准备</category>
            <category>Vue</category>
        </item>
        <item>
            <title><![CDATA[diff算法]]></title>
            <link>https://qym994.github.io/auditon-10</link>
            <guid>https://qym994.github.io/auditon-10</guid>
            <pubDate>Wed, 10 Jan 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[diff算法]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="diff算法">diff算法<a href="#diff算法" class="hash-link" aria-label="diff算法的直接链接" title="diff算法的直接链接">​</a></h3><ol><li>diff算法在vue中被称为patching算法，虚拟DOM转换为真实DOM时就需要patch转换，在响应式数据发生变化后引起组件的重新渲染，此时会生成新的vdom，执行patch函数传入新旧两次的虚拟DOM比较变化的地方，转换为最小量的真实DOM操作，高效的更新视图</li><li>patch函数是一个递归过程，遵循深度优先，同层比较的策略<ol><li>首先判断两个根节点是否为相同类型节点(通过key或节点类型)，不同则删除并重新创建</li><li>若双方都是文本类型直接更新文本内容</li><li>若双方都是元素节点则递归更新子元素，同时更新元素属性</li></ol></li><li>编译期优化patchflag</li></ol>]]></content:encoded>
            <category>面试准备</category>
            <category>Vue</category>
        </item>
        <item>
            <title><![CDATA[虚拟DOM]]></title>
            <link>https://qym994.github.io/auditon-9</link>
            <guid>https://qym994.github.io/auditon-9</guid>
            <pubDate>Tue, 09 Jan 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[虚拟DOM]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="虚拟dom">虚拟DOM<a href="#虚拟dom" class="hash-link" aria-label="虚拟DOM的直接链接" title="虚拟DOM的直接链接">​</a></h3><ol><li>定义：虚拟DOM(vdom)就是虚拟的DOM对象，通过不同的属性描述一个视图结构，较之与真实DOM，虚拟DOM只描述了最核心的部分，更新DOM变得更轻量。</li><li>好处：</li></ol><ul><li>通过将真实节点抽象成VNode，<strong>减少了直接操作的DOM的次数</strong>，从而提高程序性能，比如在diff，clone等操作时，由于真实元素包括了其他内容，如果能转为操作一个虚拟js对象会简单很多。频繁操作DOM容易引起页面的重绘和回流</li><li>方便跨平台</li></ul><ol start="3"><li>生成方式:</li></ol><ul><li>写vue组件后模板template会被compiler编译成渲染函数，返回的对象就是虚拟DOM，再patch转为真实DOM生效</li><li>响应式数据发生变化后会引起组件的重新渲染，此时会生成新的vdom，和之前的渲染结果diff再渲染，转换为最小量的真实DOM操作，高效的更新视图</li></ul>]]></content:encoded>
            <category>面试准备</category>
            <category>vue</category>
        </item>
        <item>
            <title><![CDATA[nextTick]]></title>
            <link>https://qym994.github.io/auditon-8</link>
            <guid>https://qym994.github.io/auditon-8</guid>
            <pubDate>Mon, 08 Jan 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[nextTick]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="nexttick">nextTick<a href="#nexttick" class="hash-link" aria-label="nextTick的直接链接" title="nextTick的直接链接">​</a></h3><ol><li>定义：nextTick是等待下一次DOM更新刷新的工具方法</li><li>事件循环eventloop</li></ol><ul><li>调用栈：当一个函数被调用时，它的执行环境会作为一个栈帧(frame)插入栈顶，函数执行完毕会自动弹出栈帧</li><li><ul><li>其实可以从调用栈看出函数作用域的包含关系</li></ul></li><li>任务队列：存储将要执行的函数，触发一个事件时，不是直接把事件放到调用栈中，而是放到消息队列中排队</li><li><table><thead><tr><th>宏任务</th><th>浏览器</th><th>Nodejs</th></tr></thead><tbody><tr><td>setTimeout</td><td>√</td><td>×</td></tr><tr><td>setInterval</td><td>√</td><td>√</td></tr><tr><td>I/O</td><td>√</td><td>√</td></tr><tr><td>requestAnimationFrame</td><td>√</td><td>×</td></tr><tr><td>UIrendering</td><td>√</td><td>×</td></tr><tr><td>setImmediate</td><td>×</td><td>√</td></tr></tbody></table></li><li><table><thead><tr><th>微任务</th><th>浏览器</th><th>Nodejs</th></tr></thead><tbody><tr><td>Propmise.then/catch/finally</td><td>√</td><td>√</td></tr><tr><td>queueMicorotask</td><td>√</td><td>√</td></tr><tr><td>MutationObserve</td><td>√</td><td>×</td></tr><tr><td>process.nextTick</td><td>×</td><td>√</td></tr></tbody></table></li><li>整体的script(作为第一个宏任务)开始执行的时候，会把所有代码分为两部分：“同步任务”、“异步任务”<br>同步任务会直接进入主线程依次执行<br>异步任务会再分为宏任务(进入宏任务队列) 和 微任务(进入微任务队列)<br>当主线程内的任务执行完毕（主线程为空时），会检查微任务的任务队列，如果有任务，就进入主线程全部执行，如果没有就从宏任务队列读取下一个宏任务执行<br>每执行完一个宏任务就清空一次微任务队列，此过程会不断重复，这就是Event Loop</li><li><ul><li><strong>定时器的本质是指定时间后将函数添加到消息队列</strong></li></ul></li></ul><ol start="3"><li>vue的异步更新策略：如果数据发生变化，vue不会立即更新DOM，而是开启一个队列，把组件更新函数保存在队列中，在同一事件循环中发生的数据变更会异步的批量更新，也就是说修改DOM不是实时进行的，如果想获取更新后的DOM状态就需要nextTick</li><li>使用场景：</li></ol><ul><li>在created里获取DOM</li><li>响应式数据变化后获取DOM更新后的状态</li></ul>]]></content:encoded>
            <category>面试准备</category>
            <category>vue</category>
        </item>
        <item>
            <title><![CDATA[history和hash模式]]></title>
            <link>https://qym994.github.io/auditon-7</link>
            <guid>https://qym994.github.io/auditon-7</guid>
            <pubDate>Sun, 07 Jan 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[v-router有三个模式]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="v-router有三个模式">v-router有三个模式<a href="#v-router有三个模式" class="hash-link" aria-label="v-router有三个模式的直接链接" title="v-router有三个模式的直接链接">​</a></h3><p>hash模式 history模式 memory模式
区别只在url形式 </p><ol><li>hash：<code>http://xxx.com/#/yyy</code></li></ol><ul><li>在url栏中显示已hash的形式，使用部署更简单  </li></ul><ol start="2"><li>history:<code>http://xxx.com/yyy</code></li></ol><ul><li>在url栏中更简洁美观，应用时需要配置，web服务器需要做回退处理，否则会出现刷新404的问题</li></ul>]]></content:encoded>
            <category>面试准备</category>
            <category>vue</category>
            <category>v-router</category>
        </item>
        <item>
            <title><![CDATA[ref和reacitive]]></title>
            <link>https://qym994.github.io/auditon-6</link>
            <guid>https://qym994.github.io/auditon-6</guid>
            <pubDate>Sat, 06 Jan 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[ref和reacitive]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="ref和reacitive">ref和reacitive<a href="#ref和reacitive" class="hash-link" aria-label="ref和reacitive的直接链接" title="ref和reacitive的直接链接">​</a></h3><ol><li>ref</li></ol><ul><li>ref用来处理单值的响应式</li><li>在scipt中如需访问ref响应式数据需要加上<code>.value</code>才能正常访问  </li><li>通过内部封装一个Reflmpl类并设置get和set方法实现响应式</li></ul><ol start="2"><li>reacitive</li></ol><ul><li>reactive用来处理对象的响应式</li><li>使用展开运算符(...)展开reactive的响应式对象会使其失去响应式，可结合toRefs再展开</li><li>通过借助Proxy代理对象实现响应式</li></ul>]]></content:encoded>
            <category>面试准备</category>
            <category>Vue</category>
        </item>
        <item>
            <title><![CDATA[双向绑定]]></title>
            <link>https://qym994.github.io/auditon-5</link>
            <guid>https://qym994.github.io/auditon-5</guid>
            <pubDate>Fri, 05 Jan 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[双向绑定]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="双向绑定">双向绑定<a href="#双向绑定" class="hash-link" aria-label="双向绑定的直接链接" title="双向绑定的直接链接">​</a></h3><ol><li>定义：双向绑定就是v-model，将一个响应式数据绑定到视图<br>视图变化能改变该值，数据变化也能改变视图</li><li>v-model是一个语法糖，默认情况下相当于<code>：value</code>和<code>@input</code>通常在表单项中使用</li><li>表单单选type="checkbox"可以结合true-value和false-value  </li></ol><ul><li><code>const text = ref("是")</code></li><li><code>&lt;input type = checkbox v-model = text true-value="是" false-value = "否"/&gt;</code> </li></ul><ol start="4"><li>表单多选type="checkbox"与单选方法相同，使用一个响应式的数据接收数据</li><li>如需要选项控制其他元素的可操作性，例如：同意隐私设置登录<br>可以结合<code>:disabled</code>取反"同意选项"<br><strong>假如表达需要默认为空，则v-model绑定一个空的响应式数据即可</strong></li></ol>]]></content:encoded>
            <category>面试准备</category>
            <category>Vue</category>
        </item>
        <item>
            <title><![CDATA[v-for/v-if]]></title>
            <link>https://qym994.github.io/auditon-4</link>
            <guid>https://qym994.github.io/auditon-4</guid>
            <pubDate>Thu, 04 Jan 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[v-for和v-if]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="v-for和v-if">v-for和v-if<a href="#v-for和v-if" class="hash-link" aria-label="v-for和v-if的直接链接" title="v-for和v-if的直接链接">​</a></h3><p><strong>实际使用中不要将v-for和v-if一起使用</strong><br>
<strong>性能消耗v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销</strong></p><ol><li>v-show</li></ol><ul><li>v-show通过css样式的display：none控制元素显隐  </li><li>当用v-show来隐藏元素时，只会在初次加载时渲染此dom节点，之后都是通用display来控制显隐，</li></ul><ol start="2"><li>v-if  </li></ol><ul><li>v-if通过直接控制虚拟DOM中的元素节点间接控制真实DOM上的节点控制元素显隐   </li><li>当用v-if来隐藏元素时，初次加载时就不用渲染此dom节点，提升页面加载速度</li></ul>]]></content:encoded>
            <category>面试准备</category>
            <category>Vue</category>
        </item>
        <item>
            <title><![CDATA[数据持久化和本地存储]]></title>
            <link>https://qym994.github.io/auditon-3</link>
            <guid>https://qym994.github.io/auditon-3</guid>
            <pubDate>Wed, 03 Jan 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[vuex中的state数据丢失]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="vuex中的state数据丢失">vuex中的state数据丢失<a href="#vuex中的state数据丢失" class="hash-link" aria-label="vuex中的state数据丢失的直接链接" title="vuex中的state数据丢失的直接链接">​</a></h3><ol><li>原因：vuex存储的数据只是在页面中，相当于全局变量，页面刷新的时候vuex里的数据会重新初始化，导致数据丢失。
因为vuex里的数据是保存在运行内存中的，当页面刷新时，页面会重新加载vue实例，vuex里面的数据就会被重新赋值</li><li>解决方法：将vuex中的数据直接保存到浏览器缓存中（sessionStorage、localStorage、cookie）</li></ol><ul><li>直接在vuex修改数据方法中将数据存储到浏览器本地存储中 </li><li>引入第三方库进行持久化存储</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="pinia数据持久化">pinia数据持久化<a href="#pinia数据持久化" class="hash-link" aria-label="pinia数据持久化的直接链接" title="pinia数据持久化的直接链接">​</a></h3><ol><li>安装插件persist</li><li>在App.vue中引入并挂载</li><li>数据缓存并配置</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="本地存储">本地存储<a href="#本地存储" class="hash-link" aria-label="本地存储的直接链接" title="本地存储的直接链接">​</a></h3><ol><li>sessionStorage会话存储<code>sessionStorage.setItem("属性名"，"属性值")</code></li><li>logcalStorage本地存储<code>localStorage.setItem("属性名","属性值")</code></li><li>会话存储和本地存储都有相同的方法setItem,getItem,removeItem,clear</li></ol>]]></content:encoded>
            <category>面试准备</category>
            <category>vuex</category>
            <category>pinia</category>
            <category>Vue</category>
        </item>
        <item>
            <title><![CDATA[vue中组件通信]]></title>
            <link>https://qym994.github.io/auditon-1</link>
            <guid>https://qym994.github.io/auditon-1</guid>
            <pubDate>Mon, 01 Jan 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[vue中组件通信]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="vue中组件通信">vue中组件通信<a href="#vue中组件通信" class="hash-link" aria-label="vue中组件通信的直接链接" title="vue中组件通信的直接链接">​</a></h3><ol><li>父子组件通信</li></ol><ul><li>props </li><li><ul><li>子组件使用<code>const props = defineProps([x,y,z])</code>定义属性名，可以传入对象进行配置  </li></ul></li><li><ul><li>父组件中在创建子组件实例时使用子组件定义的属性名传递参数  </li></ul></li><li><ul><li><strong>父组件传递给子组件的props是只读的</strong></li></ul></li><li>属性透传</li><li><ul><li>在组件中设置属性，会自动传递给子组件的根元素，会继续传递给子元素</li></ul></li><li><ul><li>透传会发生在没有被声明为props和emit的属性上</li></ul></li><li><ul><li><strong>*自动透传只能传递给单根子组件</strong></li></ul></li><li><ul><li>模板中使用$attr手动访问透传属`性，在scipt中使用useAttrs()获取透传属性</li></ul></li><li><ul><li>在script标签中(非setup语法糖)使用<code>inheritAttrs：false</code>设置不发生自动透传  </li></ul></li><li>emits</li><li><ul><li>在子元素中使用<code>const emits = defineEmits([xxx])</code>定义事件名</li></ul></li><li><ul><li>在父元素中<code>@xxx = emits(yyy)</code>给xxx绑定yyy事件触发  </li></ul></li><li>ref</li><li><ul><li>给DOM节点添加ref属性，即起别名，通过$refs属性获取该节点</li></ul></li><li><ul><li>给组件添加ref属性，即起别名，通过$refs调用获取中的属性，方法</li></ul></li><li><ul><li>假如同时使用ref添加响应式数据需要指定同一属性名<code>const x = ref(null) </code></li></ul></li><li><ul><li><strong>vue3中ref获取节点所以必须在mounted之后才能获取到元素，因为setup执行时，template中的元素还没挂载到页面上</strong></li></ul></li><li>依赖注入</li><li><ul><li>在祖先组件中设置依赖<code>provide(name,value)</code></li></ul></li><li><ul><li>在后代组件中注入数据<code>const value = inject(name,default)</code></li></ul></li><li><ul><li>若有同名依赖取最近一层的祖先元素依赖</li></ul></li><li>状态管理工具</li><li>使用pinia或vuex等状态管理工具进行全局的数据控制</li></ul>]]></content:encoded>
            <category>面试准备</category>
            <category>Vue</category>
        </item>
    </channel>
</rss>