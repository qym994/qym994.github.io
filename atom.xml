<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://qym994.github.io/</id>
    <title>qym的个人主页 Blog</title>
    <updated>2023-04-01T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://qym994.github.io/"/>
    <subtitle>qym的个人主页 Blog</subtitle>
    <icon>https://qym994.github.io/img/qym.ico</icon>
    <entry>
        <title type="html"><![CDATA[不正经博客]]></title>
        <id>https://qym994.github.io/不正经博客1</id>
        <link href="https://qym994.github.io/不正经博客1"/>
        <updated>2023-04-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[不正经博客]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="不正经博客">不正经博客<a href="#不正经博客" class="hash-link" aria-label="不正经博客的直接链接" title="不正经博客的直接链接">​</a></h3><p>在一个不是很正经的日子里，我写下了这篇博客</p><p>自己学习了很久的前端开发有了小的进展，这让我对未来充满了期待又有些迷茫。
这次的选择题做对了吗?</p>]]></content>
        <author>
            <name>qym</name>
            <uri>https://github.com/qym994</uri>
        </author>
        <category label="随笔" term="随笔"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[v-for的key问题]]></title>
        <id>https://qym994.github.io/qym-vue-6</id>
        <link href="https://qym994.github.io/qym-vue-6"/>
        <updated>2023-03-28T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[v-for的key问题]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="v-for的key问题">v-for的key问题<a href="#v-for的key问题" class="hash-link" aria-label="v-for的key问题的直接链接" title="v-for的key问题的直接链接">​</a></h3><p>使用v-for遍历时，v-for遍历时旧的结构和新的结构时按照顺序对比的<br>
<!-- -->在更新节点时，会比较新旧节点，由变化才会修改(diff算法)<br>
<!-- -->为元素指定一个唯一的key后就按照key去比较而不是顺序</p>]]></content>
        <author>
            <name>qym</name>
            <uri>https://github.com/qym994</uri>
        </author>
        <category label="Vue" term="Vue"/>
        <category label="问题回顾" term="问题回顾"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[async属性和defer属性]]></title>
        <id>https://qym994.github.io/qym-js-7</id>
        <link href="https://qym994.github.io/qym-js-7"/>
        <updated>2023-03-16T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[script标签的async和defer属性]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="script标签的async和defer属性">script标签的async和defer属性<a href="#script标签的async和defer属性" class="hash-link" aria-label="script标签的async和defer属性的直接链接" title="script标签的async和defer属性的直接链接">​</a></h3><p>浏览器在进行解析的时候遇到script标签的外部文件会优先解析<br>
<!-- -->由于无法确定scipt标签中脚本的大小，为了避免阻塞引入async和defer属性  </p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="async属性--更适合第三方脚本">async属性  （更适合第三方脚本）<a href="#async属性--更适合第三方脚本" class="hash-link" aria-label="async属性  （更适合第三方脚本）的直接链接" title="async属性  （更适合第三方脚本）的直接链接">​</a></h4><p>异步执行：浏览器进行html解析，遇到带有async属性的scipt标签后，浏览器立即进行下载<br>
<!-- -->同时继续加载界面，下载完成后执行脚本（不管html是否解析完毕）<br>
<strong>注意</strong>假如脚本修改DOM节点可能会出错</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="defer属性">defer属性<a href="#defer属性" class="hash-link" aria-label="defer属性的直接链接" title="defer属性的直接链接">​</a></h4><p>推迟执行：浏览器进行html解析，遇到带有defer属性的scipt标签后，浏览器立即进行下载<br>
<!-- -->同时继续加载界面，等到html解析完毕后执行脚本  </p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="兼容性">兼容性<a href="#兼容性" class="hash-link" aria-label="兼容性的直接链接" title="兼容性的直接链接">​</a></h4><p>假如浏览器无法兼容这两个属性可以选择把script标签放在页面底部</p>]]></content>
        <author>
            <name>qym</name>
            <uri>https://github.com/qym994</uri>
        </author>
        <category label="JavaScript" term="JavaScript"/>
        <category label="问题回顾" term="问题回顾"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[粘性定位失效的问题]]></title>
        <id>https://qym994.github.io/qym-vue-5</id>
        <link href="https://qym994.github.io/qym-vue-5"/>
        <updated>2023-03-07T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[粘滞定位失效的问题]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="粘滞定位失效的问题">粘滞定位失效的问题<a href="#粘滞定位失效的问题" class="hash-link" aria-label="粘滞定位失效的问题的直接链接" title="粘滞定位失效的问题的直接链接">​</a></h3><p>写项目时发现batterscroll里的粘滞定位失效了
batterscroll使用时需设置父元素overflow：hidden影响了粘性定位</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="粘性定位的原理">粘性定位的原理<a href="#粘性定位的原理" class="hash-link" aria-label="粘性定位的原理的直接链接" title="粘性定位的原理的直接链接">​</a></h3><p>Sticky（当它表现为 fixed 定位的特性时）会根据最近的滚动容器（nearest scrollport）自动计算偏移量。
其中有一个非常重要的概念就是 nearest scrollport，它表示 sticky 元素在即将消失前会相对它最近的 scrollport 去做定位。
须指定top, right, bottom 或 left 四个阈值其中之一（且达到设定的阈值），才可使粘性定位生效。否则其行为与相对定位相同；</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="粘性定位失效的情况">粘性定位失效的情况<a href="#粘性定位失效的情况" class="hash-link" aria-label="粘性定位失效的情况的直接链接" title="粘性定位失效的情况的直接链接">​</a></h3><ol><li>包裹的父容器高度与sticky元素一致</li><li>包裹的父容器设置了overflow为非visible</li><li>没有指定top, right, bottom 或 left</li></ol>]]></content>
        <author>
            <name>qym</name>
            <uri>https://github.com/qym994</uri>
        </author>
        <category label="Vue" term="Vue"/>
        <category label="问题回顾" term="问题回顾"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[箭头函数和普通函数区别]]></title>
        <id>https://qym994.github.io/qym-js-6</id>
        <link href="https://qym994.github.io/qym-js-6"/>
        <updated>2023-03-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[箭头函数和普通函数的区别]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="箭头函数和普通函数的区别">箭头函数和普通函数的区别<a href="#箭头函数和普通函数的区别" class="hash-link" aria-label="箭头函数和普通函数的区别的直接链接" title="箭头函数和普通函数的区别的直接链接">​</a></h3><ol><li>箭头函数在创建时不会有'Construct'方法，没有构造能力，无proptotype属性</li><li>箭头函数没有'arguments'对象，和第一点都是不需要复用的原因</li><li>this的指向  </li></ol><ul><li>普通函数的this是动态的，是实际执行的时候确认的  <ul><li>以函数形式调用 this =&gt; window对象</li><li>以方法形式调用 this =&gt; 调用方法的对象</li><li>构造函数中 this =&gt; 新创建的对象</li></ul></li><li>箭头函数的this在创建的时候固定为外部函数的this</li><li>顺便复习一下this指向的改变方法(箭头函数无法更改)<ul><li>call 调用方式<code>fn.call(xxx)</code>传入的第一个参数会变成fn的this指向，后续的参数作为实参传入</li><li>apply 调用方式<code>fn.apply(xxx)</code>传入的第一个参数会变成fn的this指向，后续的参数使用数据作为实参传入</li><li>bind  调用方式<code>const newfn() = fn.bind(xxx)</code>传入的第一个参数会变成newfn的this指向,后续的参数会绑定给newfn的实参</li></ul></li></ul>]]></content>
        <author>
            <name>qym</name>
            <uri>https://github.com/qym994</uri>
        </author>
        <category label="JavaScript" term="JavaScript"/>
        <category label="问题回顾" term="问题回顾"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[vant轻提示不生效]]></title>
        <id>https://qym994.github.io/qym-vue-4</id>
        <link href="https://qym994.github.io/qym-vue-4"/>
        <updated>2023-02-20T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[vant轻提示不生效]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="vant轻提示不生效">vant轻提示不生效<a href="#vant轻提示不生效" class="hash-link" aria-label="vant轻提示不生效的直接链接" title="vant轻提示不生效的直接链接">​</a></h3><p>Vant 中有个别组件是以函数的形式提供的<br>
<!-- -->包括 Toast，Dialog，Notify 和 ImagePreview 组件<br>
<!-- -->在使用函数组件时，unplugin-vue-components 无法自动引入对应的样式，因此需要手动引入样式<br>
<!-- -->引入Notify组件<code>import 'vant/es/notify/style'</code><br>
<!-- -->引入Toast组件<code>import 'vant/es/toast/style'</code></p>]]></content>
        <author>
            <name>qym</name>
            <uri>https://github.com/qym994</uri>
        </author>
        <category label="Vue" term="Vue"/>
        <category label="问题回顾" term="问题回顾"/>
        <category label="vant" term="vant"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue3深层代理]]></title>
        <id>https://qym994.github.io/qym-vue-3</id>
        <link href="https://qym994.github.io/qym-vue-3"/>
        <updated>2023-02-12T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[vue3深层代理]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="vue3深层代理">vue3深层代理<a href="#vue3深层代理" class="hash-link" aria-label="vue3深层代理的直接链接" title="vue3深层代理的直接链接">​</a></h3><p>为啥发现这个问题是我在做项目时发现vant引入的Form表单失去焦点自动提交<br>
<!-- -->原因是没有声明变量接受变量，但在setup语法糖中出现了问题：用数组接收表单数据报错<br>
<!-- -->校验发现必须单独申明v-model也就是表单input中的每一个变量<br>
<!-- -->错以为是reactive的代理是浅层的<br>
<!-- -->只能舍弃语法糖写法，在setup()函数中声明，最后return{...toRefs(userinfo)}
reactive()返回的是一个对象的深层代理<br>
<!-- -->shallowReactive()创建的是一个对象的浅层代理</p>]]></content>
        <author>
            <name>qym</name>
            <uri>https://github.com/qym994</uri>
        </author>
        <category label="Vue" term="Vue"/>
        <category label="问题回顾" term="问题回顾"/>
        <category label="vant" term="vant"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[响应式原理]]></title>
        <id>https://qym994.github.io/qym-vue-2</id>
        <link href="https://qym994.github.io/qym-vue-2"/>
        <updated>2023-02-07T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[响应式原理]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="响应式原理">响应式原理<a href="#响应式原理" class="hash-link" aria-label="响应式原理的直接链接" title="响应式原理的直接链接">​</a></h3><p>只有被vue代理的对象才是响应式的，vue3中使用代理模式完成对象的响应式改造<br>
<!-- -->响应式数据可以通过组件实例直接访问<br>
<!-- -->普通对象在被修改时不会触发元素的重新渲染  </p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const obj={name:qym}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//handler用来指定代理的行为</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const handler = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    get(target,prop,recevier){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //target:被代理的对象 prop读取的属性 recevier代理对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return target[prop]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        track()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    set(target,prop,recevier.value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //前三个参数同上，value是修改的属性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    target[prop] = value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    trigger()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const proxy = new Proxy(obj,handler) //创建代理对象 </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码中核心是track方法和trigger方法<br>
<strong>track：在vue代理读取属性时会先进行追踪，记录使用该值的位置<br>trigger: 修改被代理的值后，触发所有track记录的位置进行更新</strong></p>]]></content>
        <author>
            <name>qym</name>
            <uri>https://github.com/qym994</uri>
        </author>
        <category label="Vue" term="Vue"/>
        <category label="问题回顾" term="问题回顾"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[通过 url 传递参数控制页面显示数据的两种方式]]></title>
        <id>https://qym994.github.io/qym-node.js-1</id>
        <link href="https://qym994.github.io/qym-node.js-1"/>
        <updated>2023-02-03T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[通过 url 传递参数控制页面显示数据的两种方式]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="通过-url-传递参数控制页面显示数据的两种方式">通过 url 传递参数控制页面显示数据的两种方式<a href="#通过-url-传递参数控制页面显示数据的两种方式" class="hash-link" aria-label="通过 url 传递参数控制页面显示数据的两种方式的直接链接" title="通过 url 传递参数控制页面显示数据的两种方式的直接链接">​</a></h3><ol><li>query查询字符串传参
get请求默认通过查询字符串传递参数，服务器端以<code>/xxx?y=z</code>的形式接受"参数</li><li>param传参
get请求可以以param的形式传参<code>/xxx/:y</code><br><strong>query 传参配置的是path，而params传参配置的是name，query传递的参数会显示在地址栏中</strong><strong>query在路由配置不需要设置参数，而params必须设置(指定"：y")</strong></li><li>二者思想区别
约定优于配置：query传递参数需要指定属性名，param在配置路由时已经指定完毕<br>换句话说query需要配置属性名，而param已经约定好了传参时不用再配置</li></ol>]]></content>
        <author>
            <name>qym</name>
            <uri>https://github.com/qym994</uri>
        </author>
        <category label="Node.Js" term="Node.Js"/>
        <category label="问题回顾" term="问题回顾"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[在外部的js文件中使用pinia store中的数据报错未挂载pinia]]></title>
        <id>https://qym994.github.io/qym-vue-1</id>
        <link href="https://qym994.github.io/qym-vue-1"/>
        <updated>2023-01-28T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[在外部的js文件中使用pinia store中的数据报错未挂载pinia]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="在外部的js文件中使用pinia-store中的数据报错未挂载pinia">在外部的js文件中使用pinia store中的数据报错未挂载pinia<a href="#在外部的js文件中使用pinia-store中的数据报错未挂载pinia" class="hash-link" aria-label="在外部的js文件中使用pinia store中的数据报错未挂载pinia的直接链接" title="在外部的js文件中使用pinia store中的数据报错未挂载pinia的直接链接">​</a></h3><p>写路由时需要用到store里的用户登录状态,报错为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">`Error: [🍍]: getActivePinia was called with no active Pinia. Did you forget to install pinia?  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const pinia = createPinia()  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">app.use(pinia)`</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>解决方法创建store时，导出pinia实例 </p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">import { createPinia } from 'pinia';</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const pinia = createPinia()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">export default pinia</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在使用时传递pinia实例  </p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">import pinia from "../store/user"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import { useUserStore } from "../store/user";</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const store = useUserStore(pinia)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>qym</name>
            <uri>https://github.com/qym994</uri>
        </author>
        <category label="Vue" term="Vue"/>
        <category label="问题回顾" term="问题回顾"/>
        <category label="pinia" term="pinia"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[可变参数]]></title>
        <id>https://qym994.github.io/qym-js-5</id>
        <link href="https://qym994.github.io/qym-js-5"/>
        <updated>2023-01-21T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[arguments]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="arguments">arguments<a href="#arguments" class="hash-link" aria-label="arguments的直接链接" title="arguments的直接链接">​</a></h3><p>arguments是函数中的隐含参数，是一个伪数组对象，用来存储函数的实参<br>
<!-- -->无论用户是否定义形参，实参都会存到arguments对象中，可以通过索引读取实参  </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="可变参数">可变参数<a href="#可变参数" class="hash-link" aria-label="可变参数的直接链接" title="可变参数的直接链接">​</a></h3><p>可变参数<code>...args</code>在定义函数时将参数指定为可变参数<br>
<!-- -->可变参数<code>args</code>是一个数组可以使用数组的方法，可以命名，也可以配合其他参数</p>]]></content>
        <author>
            <name>qym</name>
            <uri>https://github.com/qym994</uri>
        </author>
        <category label="JavaScript" term="JavaScript"/>
        <category label="问题回顾" term="问题回顾"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[事件传播]]></title>
        <id>https://qym994.github.io/qym-js-4</id>
        <link href="https://qym994.github.io/qym-js-4"/>
        <updated>2023-01-15T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[事件对象event]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="事件对象event">事件对象event<a href="#事件对象event" class="hash-link" aria-label="事件对象event的直接链接" title="事件对象event的直接链接">​</a></h3><p>事件对象是浏览器在事件触发时创建的对象，其中封装了事件相关的各种信息<br>
<!-- -->在事件的回调函数中定义一个形参接受事件对象，例如：<br>
<code>const box.onmousemove = function(event){this/event.target}</code>    </p><ul><li>在事件的响应函数中<code>event.target</code>表示触发事件的对象</li><li><code>this</code>表示绑定事件的对象  </li><li><code>event.stopPropagation()</code> 取消事件传导  </li><li><code>event.preventDefault</code>取消默认行为，例如取消表单提交，超链接跳转</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="事件的传播机制">事件的传播机制<a href="#事件的传播机制" class="hash-link" aria-label="事件的传播机制的直接链接" title="事件的传播机制的直接链接">​</a></h3><p>DOM中事件传播分为三个阶段：1.捕获阶段 2.目标阶段 3.冒泡阶段 </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="事件的冒泡bubble">事件的冒泡(bubble)<a href="#事件的冒泡bubble" class="hash-link" aria-label="事件的冒泡(bubble)的直接链接" title="事件的冒泡(bubble)的直接链接">​</a></h3><p>事件的冒泡就是指事件的向上传导</p><ul><li>当元素上的事件触发时，其祖先元素的相同事件也会触发 后代触发=&gt;父类触发=&gt;祖先触发  </li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="事件的委派">事件的委派<a href="#事件的委派" class="hash-link" aria-label="事件的委派的直接链接" title="事件的委派的直接链接">​</a></h3><p>本该绑定给多个元素的事件，统一绑定给document，由于事件的冒泡，所有的document中的元素都会触发事件
这样可以降低代码复杂度维护，利用<code>event.target</code>做触发判断就可以了<br>
<!-- -->给 父元素注册事件 ，当我们触发子元素的时候，会冒泡到父元素身上，从而触发父元素的事件</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="事件的捕获">事件的捕获<a href="#事件的捕获" class="hash-link" aria-label="事件的捕获的直接链接" title="事件的捕获的直接链接">​</a></h3><p>事件由外到内的传播，事件触发后会从当前元素最大的祖先元素开始向当前元素进行事件捕获
如果希望在捕获阶段触发事件将<code>addEventListener</code>的第三个参数设置为true</p>]]></content>
        <author>
            <name>qym</name>
            <uri>https://github.com/qym994</uri>
        </author>
        <category label="JavaScript" term="JavaScript"/>
        <category label="问题回顾" term="问题回顾"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[常用的数组方法]]></title>
        <id>https://qym994.github.io/qym-js-3</id>
        <link href="https://qym994.github.io/qym-js-3"/>
        <updated>2023-01-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[常用的数组方法]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="常用的数组方法">常用的数组方法<a href="#常用的数组方法" class="hash-link" aria-label="常用的数组方法的直接链接" title="常用的数组方法的直接链接">​</a></h3><ol><li><code>Array.push()</code>将传入的参数追加到原数组的末尾，push方法可传多个参数和单个参数  </li></ol><ul><li><strong>如果传入另一个数组将不会拆分，会作为整体即一个子元素传入(可用...展开数组)</strong></li></ul><ol start="2"><li><code>Array.forEach((item,index,thisArr)=&gt;{})</code></li></ol><ul><li>item当前遍历到的元素，index遍历到的元素索引，thisArr表示当前数组
3.<code>Array.map((item,index,thisArr)=&gt;{retrun xxx})</code>  </li><li>参数同上 <strong>xxx表示对数组的处理</strong><br>4.<code>Array.filter((item,index,thisArr)=&gt;{retrun xxx})</code>  </li><li>参数同上 <strong>xxx表示过滤的条件(判断语句)</strong><br>5.<code>Array.splice()</code>  </li><li>传入两个参数时进行删除，第一个参数是开始删除的索引，第二个参数是删除的元素个数</li><li>传入三个参数时进行修改，第一个参数是插入的索引，第二个参数修改的元素个数，第三个参数是修改的元素</li></ul>]]></content>
        <author>
            <name>qym</name>
            <uri>https://github.com/qym994</uri>
        </author>
        <category label="JavaScript" term="JavaScript"/>
        <category label="问题回顾" term="问题回顾"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Esmodule和Commonjs规范]]></title>
        <id>https://qym994.github.io/qym-js-2</id>
        <link href="https://qym994.github.io/qym-js-2"/>
        <updated>2023-01-07T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Esmodule和Commonjs规范]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="esmodule和commonjs规范">Esmodule和Commonjs规范<a href="#esmodule和commonjs规范" class="hash-link" aria-label="Esmodule和Commonjs规范的直接链接" title="Esmodule和Commonjs规范的直接链接">​</a></h3><p>commonjs和esmodule是目前前端主要的模块化方案</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="commonjs">Commonjs<a href="#commonjs" class="hash-link" aria-label="Commonjs的直接链接" title="Commonjs的直接链接">​</a></h4><p>commonjs也叫cjs,在node中每一个js文件都是一个单独的模块<br>
<!-- -->这个模块中包含CommonJS的规范的核心变量: <strong>exports， module.exports, require</strong><br>
<!-- -->exports和module.exports可以负责对模块中的内容进行导出    </p><ul><li>exports和module.exports本来指向的是同一个引用地址，但是真正导入的是module.exports   </li><li>require函数可以帮助我们导入其他模块（自定义模块，系统模块，第三方库）<br><strong>注意</strong>  commonjs加载是同步的，所以必须等到相应的模块加载完毕，才执行后续代码<br>在浏览器环境中同步请求资源可能会引起卡顿<br>加载模块的时候，每一个模块上会有一个 loaded 布尔值属性避免重复加载  </li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="esmodule">Esmodule<a href="#esmodule" class="hash-link" aria-label="Esmodule的直接链接" title="Esmodule的直接链接">​</a></h4><p>ES Module 使用 import导入 和 export导出</p><ul><li>默认导出的情况下可以不指定名字，引入也可以不使用"{}"并自己命名
<strong>使用 ES Module 将会自动开启严格模式</strong></li></ul>]]></content>
        <author>
            <name>qym</name>
            <uri>https://github.com/qym994</uri>
        </author>
        <category label="模块化" term="模块化"/>
        <category label="问题回顾" term="问题回顾"/>
        <category label="node.js" term="node.js"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[正则表达式]]></title>
        <id>https://qym994.github.io/qym-js-1</id>
        <link href="https://qym994.github.io/qym-js-1"/>
        <updated>2023-01-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[正则表达式]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="正则表达式">正则表达式<a href="#正则表达式" class="hash-link" aria-label="正则表达式的直接链接" title="正则表达式的直接链接">​</a></h3><p>写项目的时候遇到了表单验证的问题，即确定用户的提交内容是否合法<br>
<!-- -->问题在于用户名，密码以及邮箱的格式是否合规</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1-定义">1. 定义<a href="#1-定义" class="hash-link" aria-label="1. 定义的直接链接" title="1. 定义的直接链接">​</a></h4><blockquote><p>正则表达式是一个规则<br>
<!-- -->通过这个规则计算机可以检查一个字符串是否符合规则  </p></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="2-创建方式">2. 创建方式<a href="#2-创建方式" class="hash-link" aria-label="2. 创建方式的直接链接" title="2. 创建方式的直接链接">​</a></h4><blockquote><p>通过构造函数创建：
<code>let reg = new RegExp("reg","model")</code><br>
<!-- -->reg是正则本身，model是匹配模式<br>
<!-- -->通过字面量创建：
<code>reg = /reg/model</code><br>
<!-- -->参数意义同上<br>
<strong>注意</strong>：构造函数可以用变量指定正则(reg)<br>
<!-- -->转义字符<code>\</code>在函数中会自动转义一次，如需限制字符"\"要写为<code>\\</code>  </p></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="3使用">3.使用<a href="#3使用" class="hash-link" aria-label="3.使用的直接链接" title="3.使用的直接链接">​</a></h4><blockquote><ul><li>最常用的用法"匹配" ：<code>let result = reg.test(str)</code><br>str是待测项目 reg是正则表达式 result是返回的结果(布尔值)  </li><li>过滤:<code>let result = reg.exec(str)</code>提取出str中符合正则表达式的内容
<strong>注意</strong>result的结构为<code>['a','b',index:number,input:string,groups:undefined]</code>
a是符合匹配规则的整体,b是分组内容即"()"里的内容"可有多个b,index表示a在整个result中的序号,input表示输入的str
groups表示具名匹配,允许为每一个组匹配指定一个名字 ,在组中用<code>&lt;&gt;</code>命名</li></ul></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="4reg常用语法">4."reg"常用语法<a href="#4reg常用语法" class="hash-link" aria-label="4.&quot;reg&quot;常用语法的直接链接" title="4.&quot;reg&quot;常用语法的直接链接">​</a></h4><blockquote><ol><li><code>|</code> 表示或</li><li><code>[]</code> 表示字符集</li></ol><ul><li><code>[a-z]</code>表示小写字母a到z</li><li><code>[A-Z]</code>表示大写字母A到Z</li><li><code>[a-zA-Z]</code>表示任意字母  </li></ul><ol start="3"><li><code>[^]</code>表示字符集取反,例如<code>reg=/[^x]/</code>即除了x之外任意字符串</li><li><code>.</code>表示除了换行"\"以外的任意字符串,如需检查"."使用<code>\.</code></li><li><code>^</code>表示字符串开头</li><li><code>$</code>表示表示字符串结尾 <strong>注意</strong><code>^</code>和<code>$</code>常与其他正则组合使用,例如<code>/^x$/</code>表示只匹配x(完全匹配)</li><li>常用字符集  </li></ol><ul><li><code>/w</code>表示基本拉丁字母中的任意字母数字字符,包括下划线,即<code>/[a-zA-z0-9_]</code></li><li><code>/W</code>表示<code>/w</code>取反,即<code>/[^a-zA-z0-9_]</code></li><li><code>/d</code>表示数字,即<code>[0-9]</code></li><li><code>/D</code>表示<code>/d</code>取反,即<code>[^0-9]</code></li></ul><ol start="8"><li>量词</li></ol><ul><li><code>{m}</code>表示恰好m个只对前面的字符使用,可使用"()"进行量词分组<br>例如<code>/a{3}/</code>匹配"aaa",<code>/(ab){3}/</code>匹配"ababab"</li><li><code>{m,n}</code>表示m到n个之间</li><li><code>{m,}</code>表示至少m个</li><li><code>{+}</code>表示至少一个,即<code>{1,}</code></li><li><code>*</code>表示任意数量,即有不报错多了也可以</li><li><code>?</code>表示0或者1茨,即<code>{0,1}</code></li></ul></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="5model匹配模式">5."model"匹配模式<a href="#5model匹配模式" class="hash-link" aria-label="5.&quot;model&quot;匹配模式的直接链接" title="5.&quot;model&quot;匹配模式的直接链接">​</a></h4><blockquote><ol><li><code>i</code>表示忽略大小写,例如<code>/[a-z]/i</code></li><li><code>g</code>表示全局匹配.默认正则表达式只匹配第一个符合条件的字符串,找到即终止  </li></ol></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="6常用正则表达式">6.常用正则表达式<a href="#6常用正则表达式" class="hash-link" aria-label="6.常用正则表达式的直接链接" title="6.常用正则表达式的直接链接">​</a></h4><blockquote><ol><li>用户名正则，4到16位（字母，数字，下划线，减号）<br><code>let uPattern = /^[a-zA-Z0-9_-]{4,16}$/</code></li><li>//密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字<br><code>let pPattern = /^.*(?=.{6,})(?=.*\d)(?=.*[A-Z])(?=.*[a-z]).*$/</code>  </li><li>//Email正则<br><code>let ePattern = /^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]{2,4})$/</code></li></ol></blockquote>]]></content>
        <author>
            <name>qym</name>
            <uri>https://github.com/qym994</uri>
        </author>
        <category label="JavaScript" term="JavaScript"/>
        <category label="问题回顾" term="问题回顾"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[移动端适配]]></title>
        <id>https://qym994.github.io/auditon-15</id>
        <link href="https://qym994.github.io/auditon-15"/>
        <updated>1900-03-02T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[移动端适配]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="移动端适配">移动端适配<a href="#移动端适配" class="hash-link" aria-label="移动端适配的直接链接" title="移动端适配的直接链接">​</a></h3><ol><li>viewport适配</li></ol><ul><li>利用完美视口适配</li><li>使用插件将css像素px转为vw适配</li><li>px 转换成 vw 不一定能完全整除，因此有一定的像素差</li></ul><ol start="2"><li>媒体查询(media query):通过媒体查询为不同的屏幕大小设置样式</li></ol><ul><li>使用max-width和min-width限定样式</li><li>页面上所有的元素都得在不同的 @media 中定义一遍不同的尺寸，代价过高</li><li>如果再多一种屏幕尺寸，就得多写一个 @media 查询块</li></ul><ol start="3"><li>rem适配</li></ol><ul><li>rem是css3新增的一个相对单位。rem为相对HTML根元素的大小，默认1rem为16px</li><li>动态的计算rem就可以实现移动端适配(结合vw)</li><li>为了方便计算我们一般设置1rem=100px，我们需要设置字体大小为100px</li><li>rem/100px = 100vw/设计图尺寸</li></ul>]]></content>
        <author>
            <name>qym</name>
            <uri>https://github.com/qym994</uri>
        </author>
        <category label="面试准备" term="面试准备"/>
        <category label="css" term="css"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[css]]></title>
        <id>https://qym994.github.io/auditon-14</id>
        <link href="https://qym994.github.io/auditon-14"/>
        <updated>1900-03-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[css选择器优先级]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="css选择器优先级">css选择器优先级<a href="#css选择器优先级" class="hash-link" aria-label="css选择器优先级的直接链接" title="css选择器优先级的直接链接">​</a></h3><p>!important&gt;内联样式&gt;id&gt;类/伪类/属性&gt;标签&gt;全局</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="盒模型">盒模型<a href="#盒模型" class="hash-link" aria-label="盒模型的直接链接" title="盒模型的直接链接">​</a></h3><p>元素可以看作一个盒子：由外到内是外边距margin，边框border，内边距padding，内容content几部分组成<br>
<!-- -->可用box-sizing控制盒模型种类：默认content-box(width指的是内容区)，可改为border-box(width包括所有内容)<br>
<!-- -->水平布局等式：margin+border+padding+content = 包含块的宽度<br>
<!-- -->等式不满足时，会强制调整：</p><ol><li>若有一个值为auto则调整值为auto的值</li><li>若无auto，优先调整右外边距margin-right</li><li>若左右外边距为auto，则均分调整(水平居中原理)</li><li>当外边距和width同时设置为auto时，外边距为0</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="bfc块级格式化环境">BFC块级格式化环境<a href="#bfc块级格式化环境" class="hash-link" aria-label="BFC块级格式化环境的直接链接" title="BFC块级格式化环境的直接链接">​</a></h3><ol><li>开启浮动</li><li>overflow设置为非默认值visible</li><li>display：flow-root</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="clearfix">clearfix<a href="#clearfix" class="hash-link" aria-label="clearfix的直接链接" title="clearfix的直接链接">​</a></h3><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">.clearfix::before,.clearfix::after{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">content:"",</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">display:table,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">clear:both</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>}
解决高度塌陷和外边距重叠</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="flex布局">flex布局<a href="#flex布局" class="hash-link" aria-label="flex布局的直接链接" title="flex布局的直接链接">​</a></h3><p>给元素设置display：flex后元素成为弹性容器，子元素变为弹性元素<br>
<!-- -->flex-direction：更改主轴(弹性子元素排列的方向)<br>
<!-- -->flex-wrap：设置子元素是否换行<br>
<!-- -->justify-content:设置元素在主轴的对齐方式<br>
<!-- -->align-item:设置元素在辅轴上的对齐方式
align-content:设置元素辅轴方向的空白空间如何分配<br>
<!-- -->flex:是flex-grow(弹性元素生长系数),flex-shrink(弹性元素收缩系数),flex-basis(弹性元素基础大小)  </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="雪碧图精灵图">雪碧图/精灵图<a href="#雪碧图精灵图" class="hash-link" aria-label="雪碧图/精灵图的直接链接" title="雪碧图/精灵图的直接链接">​</a></h3><p>将多个小的图片放到一个大图中，使用background-position决定展示的小图片</p>]]></content>
        <author>
            <name>qym</name>
            <uri>https://github.com/qym994</uri>
        </author>
        <category label="面试准备" term="面试准备"/>
        <category label="css" term="css"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[http状态码]]></title>
        <id>https://qym994.github.io/auditon-2</id>
        <link href="https://qym994.github.io/auditon-2"/>
        <updated>1900-02-02T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[http状态码]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="http状态码">http状态码<a href="#http状态码" class="hash-link" aria-label="http状态码的直接链接" title="http状态码的直接链接">​</a></h3><ol><li>定义：http状态码是服务器返回客户端的响应状态码</li><li>具体分类</li></ol><ul><li>1xx：表示通知信息，如请求收到了或正在处理</li><li><ul><li>100：Continue 客户端继续其请求</li></ul></li><li><ul><li>101：Switching Protocols 服务器切换更高级协议</li></ul></li><li>2xx：表示成功，如接受或知道了  </li><li><ul><li>200：OK 请求成功</li></ul></li><li><ul><li>201：Created 成功请求并创建资源</li></ul></li><li><ul><li>202 ：Accepted 已接受请求但还未处理</li></ul></li><li>3xx：表示重定向：如要完成请求还需要进一步行动</li><li><ul><li>301：Moved Permanently 请求的资源已经被永久移动新URI，浏览器会重新定向到新URI</li></ul></li><li><ul><li>302：Found 请求的资源临时移动，不重定向URI</li></ul></li><li>4xx：表示客户端错误，如请求中有错误的语法或不能完成</li><li><ul><li>400：Bad Request 客户端请求的语法错误</li></ul></li><li><ul><li>401：Unauthorized 客户端身份验证未通过j</li></ul></li><li><ul><li>403：Forbidden 服务器拒绝执行请求</li></ul></li><li><ul><li>404：Not Found 服务器无法找到请求的资源</li></ul></li><li>5XX：表示服务器端错误，如服务器失效</li><li><ul><li>502：Bad Gateway 错误网关</li></ul></li></ul>]]></content>
        <author>
            <name>qym</name>
            <uri>https://github.com/qym994</uri>
        </author>
        <category label="面试准备" term="面试准备"/>
        <category label="计算机网络" term="计算机网络"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何拓展一个vue组件]]></title>
        <id>https://qym994.github.io/auditon-13</id>
        <link href="https://qym994.github.io/auditon-13"/>
        <updated>1900-01-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[如何拓展一个vue组件]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何拓展一个vue组件">如何拓展一个vue组件<a href="#如何拓展一个vue组件" class="hash-link" aria-label="如何拓展一个vue组件的直接链接" title="如何拓展一个vue组件的直接链接">​</a></h3><ol><li>slot插槽作为内容拓展</li></ol><ul><li>父组件中在标签体中使用<code>&lt;子组件&gt;插槽内容&lt;/子组件&gt;</code></li><li>子组件在模板中使用<code>&lt;slot&gt;&lt;/slot&gt;</code></li><li>命名插槽</li><li><ul><li>则再子组件里使用<code>&lt;slot name = "xxx"&gt;&lt;/slot&gt;</code></li></ul></li><li><ul><li>父组件中使用v-slot属性对应，可简写为#<code>&lt;template #xxx&gt;</code></li></ul></li></ul><ol start="2"><li>选项式API引用可复用的函数，或者直接添加逻辑</li></ol>]]></content>
        <author>
            <name>qym</name>
            <uri>https://github.com/qym994</uri>
        </author>
        <category label="面试准备" term="面试准备"/>
        <category label="vue" term="vue"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue生命周期]]></title>
        <id>https://qym994.github.io/auditon-12</id>
        <link href="https://qym994.github.io/auditon-12"/>
        <updated>1900-01-12T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[vue生命周期]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="vue生命周期">vue生命周期<a href="#vue生命周期" class="hash-link" aria-label="vue生命周期的直接链接" title="vue生命周期的直接链接">​</a></h3><ol><li>定义：vue从创建到销毁的过程，在某些特定阶段用户需要添加自己的代码</li><li>vue的生命周期一共分为8个阶段：创建前后，挂载前后，更新前后和卸载前后</li><li>尝试创建组件时，一个新的生命周期就开始了</li></ol><ul><li>最早发生的是setup()函数</li><li><strong>beforeCreate：通常用于插件开发的初始化任务</strong></li><li>初始化选项式API</li><li><strong>created：组件初始化完毕，可以访问各种数据和接口数据</strong></li><li>判断是否有预编译的模板，如果有则继续，如果没有则实时编译模板得到渲染函数</li><li>beforeMount</li><li>创建并插入DOM节点</li><li><strong>mounted：DOM已经创建，可以用于获取访问数据和DOM元素，子组件等</strong></li><li>vue会不断监听响应式数据，发生变化后beforeUpdate(此时view即视图还没更新，可用于获取更新前的状态)会重新渲染，然后patch</li><li>Updated：完成view即视图的更新，更新后所有状态都是最新</li><li><strong>组件不被需要后beforeUnmounted：实例销毁前被调用，可以用于定时器，订阅的取消</strong></li><li><strong>Unmounted：销毁一个实例，清理他与其他实例的连接，解绑全部指令和事件监听器</strong></li></ul>]]></content>
        <author>
            <name>qym</name>
            <uri>https://github.com/qym994</uri>
        </author>
        <category label="面试准备" term="面试准备"/>
        <category label="vue" term="vue"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[从template到render发生了什么]]></title>
        <id>https://qym994.github.io/auditon-11</id>
        <link href="https://qym994.github.io/auditon-11"/>
        <updated>1900-01-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[从template到render发生了什么]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="从template到render发生了什么">从template到render发生了什么<a href="#从template到render发生了什么" class="hash-link" aria-label="从template到render发生了什么的直接链接" title="从template到render发生了什么的直接链接">​</a></h3><ol><li>vue中有独特的编译器模块compiler，负责将用户编写的template转化为渲染函数</li><li>这个编译过程能使程序员用HTML编写视图，并且享有编译期优化(patchflag)</li><li>在vue中编译器先对template进行解析，这一步成为parse，最后得到一个js对象即抽象语法树AST(类似于虚拟DOM描述视图)，然后对AST进行深加工的转换但不会产生新的东西，称为transform，最终将深加工后的AST生成渲染函数</li></ol>]]></content>
        <author>
            <name>qym</name>
            <uri>https://github.com/qym994</uri>
        </author>
        <category label="面试准备" term="面试准备"/>
        <category label="vue" term="vue"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[diff算法]]></title>
        <id>https://qym994.github.io/auditon-10</id>
        <link href="https://qym994.github.io/auditon-10"/>
        <updated>1900-01-10T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[diff算法]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="diff算法">diff算法<a href="#diff算法" class="hash-link" aria-label="diff算法的直接链接" title="diff算法的直接链接">​</a></h3><ol><li>diff算法在vue中被称为patching算法，虚拟DOM转换为真实DOM时就需要patch转换，在响应式数据发生变化后引起组件的重新渲染，此时会生成新的vdom，执行patch函数传入新旧两次的虚拟DOM比较变化的地方，转换为最小量的真实DOM操作，高效的更新视图</li><li>patch函数是一个递归过程，遵循深度优先，同层比较的策略<ol><li>首先判断两个根节点是否为相同类型节点(通过key或节点类型)，不同则删除并重新创建</li><li>若双方都是文本类型直接更新文本内容</li><li>若双方都是元素节点则递归更新子元素，同时更新元素属性</li></ol></li><li>编译期优化patchflag</li></ol>]]></content>
        <author>
            <name>qym</name>
            <uri>https://github.com/qym994</uri>
        </author>
        <category label="面试准备" term="面试准备"/>
        <category label="vue" term="vue"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[虚拟DOM]]></title>
        <id>https://qym994.github.io/auditon-9</id>
        <link href="https://qym994.github.io/auditon-9"/>
        <updated>1900-01-09T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[虚拟DOM]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="虚拟dom">虚拟DOM<a href="#虚拟dom" class="hash-link" aria-label="虚拟DOM的直接链接" title="虚拟DOM的直接链接">​</a></h3><ol><li>定义：虚拟DOM(vdom)就是虚拟的DOM对象，通过不同的属性描述一个视图结构，较之与真实DOM，虚拟DOM只描述了最核心的部分，更新DOM变得更轻量。</li><li>好处：</li></ol><ul><li>通过将真实节点抽象成VNode，<strong>减少了直接操作的DOM的次数</strong>，从而提高程序性能，比如在diff，clone等操作时，由于真实元素包括了其他内容，如果能转为操作一个虚拟js对象会简单很多。频繁操作DOM容易引起页面的重绘和回流</li><li>方便跨平台</li></ul><ol start="3"><li>生成方式:</li></ol><ul><li>写vue组件后模板template会被compiler编译成渲染函数，返回的对象就是虚拟DOM，再patch转为真实DOM生效</li><li>响应式数据发生变化后会引起组件的重新渲染，此时会生成新的vdom，和之前的渲染结果diff再渲染，转换为最小量的真实DOM操作，高效的更新视图</li></ul>]]></content>
        <author>
            <name>qym</name>
            <uri>https://github.com/qym994</uri>
        </author>
        <category label="面试准备" term="面试准备"/>
        <category label="vue" term="vue"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[nextTick]]></title>
        <id>https://qym994.github.io/auditon-8</id>
        <link href="https://qym994.github.io/auditon-8"/>
        <updated>1900-01-08T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[nextTick]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="nexttick">nextTick<a href="#nexttick" class="hash-link" aria-label="nextTick的直接链接" title="nextTick的直接链接">​</a></h3><ol><li>定义：nextTick是等待下一次DOM更新刷新的工具方法</li><li>事件循环eventloop</li></ol><ul><li>调用栈：当一个函数被调用时，它的执行环境会作为一个栈帧(frame)插入栈顶，函数执行完毕会自动弹出栈帧</li><li><ul><li>其实可以从调用栈看出函数作用域的包含关系</li></ul></li><li>任务队列：存储将要执行的函数，触发一个事件时，不是直接把事件放到调用栈中，而是放到消息队列中排队</li><li><table><thead><tr><th>宏任务</th><th>浏览器</th><th>Nodejs</th></tr></thead><tbody><tr><td>setTimeout</td><td>√</td><td>×</td></tr><tr><td>setInterval</td><td>√</td><td>√</td></tr><tr><td>I/O</td><td>√</td><td>√</td></tr><tr><td>requestAnimationFrame</td><td>√</td><td>×</td></tr><tr><td>UIrendering</td><td>√</td><td>×</td></tr><tr><td>setImmediate</td><td>×</td><td>√</td></tr></tbody></table></li><li><table><thead><tr><th>微任务</th><th>浏览器</th><th>Nodejs</th></tr></thead><tbody><tr><td>Propmise.then/catch/finally</td><td>√</td><td>√</td></tr><tr><td>queueMicorotask</td><td>√</td><td>√</td></tr><tr><td>MutationObserve</td><td>√</td><td>×</td></tr><tr><td>process.nextTick</td><td>×</td><td>√</td></tr></tbody></table></li><li>整体的script(作为第一个宏任务)开始执行的时候，会把所有代码分为两部分：“同步任务”、“异步任务”<br>同步任务会直接进入主线程依次执行<br>异步任务会再分为宏任务(进入宏任务队列) 和 微任务(进入微任务队列)<br>当主线程内的任务执行完毕（主线程为空时），会检查微任务的任务队列，如果有任务，就进入主线程全部执行，如果没有就从宏任务队列读取下一个宏任务执行<br>每执行完一个宏任务就清空一次微任务队列，此过程会不断重复，这就是Event Loop</li><li><ul><li><strong>定时器的本质是指定时间后将函数添加到消息队列</strong></li></ul></li></ul><ol start="3"><li>vue的异步更新策略：如果数据发生变化，vue不会立即更新DOM，而是开启一个队列，把组件更新函数保存在队列中，在同一事件循环中发生的数据变更会异步的批量更新，也就是说修改DOM不是实时进行的，如果想获取更新后的DOM状态就需要nextTick</li><li>使用场景：</li></ol><ul><li>在created里获取DOM</li><li>响应式数据变化后获取DOM更新后的状态</li></ul>]]></content>
        <author>
            <name>qym</name>
            <uri>https://github.com/qym994</uri>
        </author>
        <category label="面试准备" term="面试准备"/>
        <category label="vue" term="vue"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[history和hash模式]]></title>
        <id>https://qym994.github.io/auditon-7</id>
        <link href="https://qym994.github.io/auditon-7"/>
        <updated>1900-01-07T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[v-router有三个模式]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="v-router有三个模式">v-router有三个模式<a href="#v-router有三个模式" class="hash-link" aria-label="v-router有三个模式的直接链接" title="v-router有三个模式的直接链接">​</a></h3><p>hash模式 history模式 memory模式
区别只在url形式 </p><ol><li>hash：<code>http://xxx.com/#/yyy</code></li></ol><ul><li>在url栏中显示已hash的形式，使用部署更简单  </li></ul><ol start="2"><li>history:<code>http://xxx.com/yyy</code></li></ol><ul><li>在url栏中更简洁美观，应用时需要配置，web服务器需要做回退处理，否则会出现刷新404的问题</li></ul>]]></content>
        <author>
            <name>qym</name>
            <uri>https://github.com/qym994</uri>
        </author>
        <category label="面试准备" term="面试准备"/>
        <category label="vue" term="vue"/>
        <category label="v-router" term="v-router"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[ref和reacitive]]></title>
        <id>https://qym994.github.io/auditon-6</id>
        <link href="https://qym994.github.io/auditon-6"/>
        <updated>1900-01-06T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[ref和reacitive]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="ref和reacitive">ref和reacitive<a href="#ref和reacitive" class="hash-link" aria-label="ref和reacitive的直接链接" title="ref和reacitive的直接链接">​</a></h3><ol><li>ref</li></ol><ul><li>ref用来处理单值的响应式</li><li>在scipt中如需访问ref响应式数据需要加上<code>.value</code>才能正常访问  </li><li>通过内部封装一个Reflmpl类并设置get和set方法实现响应式</li></ul><ol start="2"><li>reacitive</li></ol><ul><li>reactive用来处理对象的响应式</li><li>使用展开运算符(...)展开reactive的响应式对象会使其失去响应式，可结合toRefs再展开</li><li>通过借助Proxy代理对象实现响应式</li></ul>]]></content>
        <author>
            <name>qym</name>
            <uri>https://github.com/qym994</uri>
        </author>
        <category label="面试准备" term="面试准备"/>
        <category label="vue" term="vue"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[双向绑定]]></title>
        <id>https://qym994.github.io/auditon-5</id>
        <link href="https://qym994.github.io/auditon-5"/>
        <updated>1900-01-05T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[双向绑定]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="双向绑定">双向绑定<a href="#双向绑定" class="hash-link" aria-label="双向绑定的直接链接" title="双向绑定的直接链接">​</a></h3><ol><li>定义：双向绑定就是v-model，将一个响应式数据绑定到视图<br>视图变化能改变该值，数据变化也能改变视图</li><li>v-model是一个语法糖，默认情况下相当于<code>：value</code>和<code>@input</code>通常在表单项中使用</li><li>表单单选type="checkbox"可以结合true-value和false-value  </li></ol><ul><li><code>const text = ref("是")</code></li><li><code>&lt;input type = checkbox v-model = text true-value="是" false-value = "否"/&gt;</code> </li></ul><ol start="4"><li>表单多选type="checkbox"与单选方法相同，使用一个响应式的数据接收数据</li><li>如需要选项控制其他元素的可操作性，例如：同意隐私设置登录<br>可以结合<code>:disabled</code>取反"同意选项"<br><strong>假如表达需要默认为空，则v-model绑定一个空的响应式数据即可</strong></li></ol>]]></content>
        <author>
            <name>qym</name>
            <uri>https://github.com/qym994</uri>
        </author>
        <category label="面试准备" term="面试准备"/>
        <category label="vue" term="vue"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[v-for/v-if]]></title>
        <id>https://qym994.github.io/auditon-4</id>
        <link href="https://qym994.github.io/auditon-4"/>
        <updated>1900-01-04T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[v-for和v-if]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="v-for和v-if">v-for和v-if<a href="#v-for和v-if" class="hash-link" aria-label="v-for和v-if的直接链接" title="v-for和v-if的直接链接">​</a></h3><p><strong>实际使用中不要将v-for和v-if一起使用</strong><br>
<strong>性能消耗v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销</strong></p><ol><li>v-show</li></ol><ul><li>v-show通过css样式的display：none控制元素显隐  </li><li>当用v-show来隐藏元素时，只会在初次加载时渲染此dom节点，之后都是通用display来控制显隐，</li></ul><ol start="2"><li>v-if  </li></ol><ul><li>v-if通过直接控制虚拟DOM中的元素节点间接控制真实DOM上的节点控制元素显隐   </li><li>当用v-if来隐藏元素时，初次加载时就不用渲染此dom节点，提升页面加载速度</li></ul>]]></content>
        <author>
            <name>qym</name>
            <uri>https://github.com/qym994</uri>
        </author>
        <category label="面试准备" term="面试准备"/>
        <category label="vue" term="vue"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据持久化和本地存储]]></title>
        <id>https://qym994.github.io/auditon-3</id>
        <link href="https://qym994.github.io/auditon-3"/>
        <updated>1900-01-03T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[vuex中的state数据丢失]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="vuex中的state数据丢失">vuex中的state数据丢失<a href="#vuex中的state数据丢失" class="hash-link" aria-label="vuex中的state数据丢失的直接链接" title="vuex中的state数据丢失的直接链接">​</a></h3><ol><li>原因：vuex存储的数据只是在页面中，相当于全局变量，页面刷新的时候vuex里的数据会重新初始化，导致数据丢失。
因为vuex里的数据是保存在运行内存中的，当页面刷新时，页面会重新加载vue实例，vuex里面的数据就会被重新赋值</li><li>解决方法：将vuex中的数据直接保存到浏览器缓存中（sessionStorage、localStorage、cookie）</li></ol><ul><li>直接在vuex修改数据方法中将数据存储到浏览器本地存储中 </li><li>引入第三方库进行持久化存储</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="pinia数据持久化">pinia数据持久化<a href="#pinia数据持久化" class="hash-link" aria-label="pinia数据持久化的直接链接" title="pinia数据持久化的直接链接">​</a></h3><ol><li>安装插件persist</li><li>在App.vue中引入并挂载</li><li>数据缓存并配置</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="本地存储">本地存储<a href="#本地存储" class="hash-link" aria-label="本地存储的直接链接" title="本地存储的直接链接">​</a></h3><ol><li>sessionStorage会话存储<code>sessionStorage.setItem("属性名"，"属性值")</code></li><li>logcalStorage本地存储<code>localStorage.setItem("属性名","属性值")</code></li><li>会话存储和本地存储都有相同的方法setItem,getItem,removeItem,clear</li></ol>]]></content>
        <author>
            <name>qym</name>
            <uri>https://github.com/qym994</uri>
        </author>
        <category label="面试准备" term="面试准备"/>
        <category label="vuex" term="vuex"/>
        <category label="pinia" term="pinia"/>
        <category label="vue" term="vue"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue中组件通信]]></title>
        <id>https://qym994.github.io/auditon-1</id>
        <link href="https://qym994.github.io/auditon-1"/>
        <updated>1900-01-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[vue中组件通信]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="vue中组件通信">vue中组件通信<a href="#vue中组件通信" class="hash-link" aria-label="vue中组件通信的直接链接" title="vue中组件通信的直接链接">​</a></h3><ol><li>父子组件通信</li></ol><ul><li>props </li><li><ul><li>子组件使用<code>const props = defineProps([x,y,z])</code>定义属性名，可以传入对象进行配置  </li></ul></li><li><ul><li>父组件中在创建子组件实例时使用子组件定义的属性名传递参数  </li></ul></li><li><ul><li><strong>父组件传递给子组件的props是只读的</strong></li></ul></li><li>属性透传</li><li><ul><li>在组件中设置属性，会自动传递给子组件的根元素，会继续传递给子元素</li></ul></li><li><ul><li>透传会发生在没有被声明为props和emit的属性上</li></ul></li><li><ul><li><strong>*自动透传只能传递给单根子组件</strong></li></ul></li><li><ul><li>模板中使用$attr手动访问透传属`性，在scipt中使用useAttrs()获取透传属性</li></ul></li><li><ul><li>在script标签中(非setup语法糖)使用<code>inheritAttrs：false</code>设置不发生自动透传  </li></ul></li><li>emits</li><li><ul><li>在子元素中使用<code>const emits = defineEmits([xxx])</code>定义事件名</li></ul></li><li><ul><li>在父元素中<code>@xxx = emits(yyy)</code>给xxx绑定yyy事件触发  </li></ul></li><li>ref</li><li><ul><li>给DOM节点添加ref属性，即起别名，通过$refs属性获取该节点</li></ul></li><li><ul><li>给组件添加ref属性，即起别名，通过$refs调用获取中的属性，方法</li></ul></li><li><ul><li>假如同时使用ref添加响应式数据需要指定同一属性名<code>const x = ref(null) </code></li></ul></li><li><ul><li><strong>vue3中ref获取节点所以必须在mounted之后才能获取到元素，因为setup执行时，template中的元素还没挂载到页面上</strong></li></ul></li><li>依赖注入</li><li><ul><li>在祖先组件中设置依赖<code>provide(name,value)</code></li></ul></li><li><ul><li>在后代组件中注入数据<code>const value = inject(name,default)</code></li></ul></li><li><ul><li>若有同名依赖取最近一层的祖先元素依赖</li></ul></li><li>状态管理工具</li><li>使用pinia或vuex等状态管理工具进行全局的数据控制</li></ul>]]></content>
        <author>
            <name>qym</name>
            <uri>https://github.com/qym994</uri>
        </author>
        <category label="面试准备" term="面试准备"/>
        <category label="vue" term="vue"/>
    </entry>
</feed>