<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>qym的个人主页 Blog</title>
        <link>https://qym994.github.io/</link>
        <description>qym的个人主页 Blog</description>
        <lastBuildDate>Sat, 01 Apr 2023 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>zh</language>
        <item>
            <title><![CDATA[不正经博客]]></title>
            <link>https://qym994.github.io/不正经博客1</link>
            <guid>https://qym994.github.io/不正经博客1</guid>
            <pubDate>Sat, 01 Apr 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[不正经博客]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="不正经博客">不正经博客<a href="#不正经博客" class="hash-link" aria-label="不正经博客的直接链接" title="不正经博客的直接链接">​</a></h3><p>在一个不是很正经的日子里，我写下了这篇博客</p><p>自己学习了很久的前端开发有了小的进展，这让我对未来充满了期待又有些迷茫。
这次的选择题做对了吗?</p>]]></content:encoded>
            <category>随笔</category>
        </item>
        <item>
            <title><![CDATA[v-for的key问题]]></title>
            <link>https://qym994.github.io/qym-vue-6</link>
            <guid>https://qym994.github.io/qym-vue-6</guid>
            <pubDate>Tue, 28 Mar 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[v-for的key问题]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="v-for的key问题">v-for的key问题<a href="#v-for的key问题" class="hash-link" aria-label="v-for的key问题的直接链接" title="v-for的key问题的直接链接">​</a></h3><p>使用v-for遍历时，v-for遍历时旧的结构和新的结构时按照顺序对比的<br>
<!-- -->在更新节点时，会比较新旧节点，由变化才会修改(diff算法)<br>
<!-- -->为元素指定一个唯一的key后就按照key去比较而不是顺序</p>]]></content:encoded>
            <category>Vue</category>
            <category>问题回顾</category>
        </item>
        <item>
            <title><![CDATA[async属性和defer属性]]></title>
            <link>https://qym994.github.io/qym-js-7</link>
            <guid>https://qym994.github.io/qym-js-7</guid>
            <pubDate>Thu, 16 Mar 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[script标签的async和defer属性]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="script标签的async和defer属性">script标签的async和defer属性<a href="#script标签的async和defer属性" class="hash-link" aria-label="script标签的async和defer属性的直接链接" title="script标签的async和defer属性的直接链接">​</a></h3><p>浏览器在进行解析的时候遇到script标签的外部文件会优先解析<br>
<!-- -->由于无法确定scipt标签中脚本的大小，为了避免阻塞引入async和defer属性  </p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="async属性--更适合第三方脚本">async属性  （更适合第三方脚本）<a href="#async属性--更适合第三方脚本" class="hash-link" aria-label="async属性  （更适合第三方脚本）的直接链接" title="async属性  （更适合第三方脚本）的直接链接">​</a></h4><p>异步执行：浏览器进行html解析，遇到带有async属性的scipt标签后，浏览器立即进行下载<br>
<!-- -->同时继续加载界面，下载完成后执行脚本（不管html是否解析完毕）<br>
<strong>注意</strong>假如脚本修改DOM节点可能会出错</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="defer属性">defer属性<a href="#defer属性" class="hash-link" aria-label="defer属性的直接链接" title="defer属性的直接链接">​</a></h4><p>推迟执行：浏览器进行html解析，遇到带有defer属性的scipt标签后，浏览器立即进行下载<br>
<!-- -->同时继续加载界面，等到html解析完毕后执行脚本  </p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="兼容性">兼容性<a href="#兼容性" class="hash-link" aria-label="兼容性的直接链接" title="兼容性的直接链接">​</a></h4><p>假如浏览器无法兼容这两个属性可以选择把script标签放在页面底部</p>]]></content:encoded>
            <category>JavaScript</category>
            <category>问题回顾</category>
        </item>
        <item>
            <title><![CDATA[粘性定位失效的问题]]></title>
            <link>https://qym994.github.io/qym-vue-5</link>
            <guid>https://qym994.github.io/qym-vue-5</guid>
            <pubDate>Tue, 07 Mar 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[粘滞定位失效的问题]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="粘滞定位失效的问题">粘滞定位失效的问题<a href="#粘滞定位失效的问题" class="hash-link" aria-label="粘滞定位失效的问题的直接链接" title="粘滞定位失效的问题的直接链接">​</a></h3><p>写项目时发现batterscroll里的粘滞定位失效了
batterscroll使用时需设置父元素overflow：hidden影响了粘性定位</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="粘性定位的原理">粘性定位的原理<a href="#粘性定位的原理" class="hash-link" aria-label="粘性定位的原理的直接链接" title="粘性定位的原理的直接链接">​</a></h3><p>Sticky（当它表现为 fixed 定位的特性时）会根据最近的滚动容器（nearest scrollport）自动计算偏移量。
其中有一个非常重要的概念就是 nearest scrollport，它表示 sticky 元素在即将消失前会相对它最近的 scrollport 去做定位。
须指定top, right, bottom 或 left 四个阈值其中之一（且达到设定的阈值），才可使粘性定位生效。否则其行为与相对定位相同；</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="粘性定位失效的情况">粘性定位失效的情况<a href="#粘性定位失效的情况" class="hash-link" aria-label="粘性定位失效的情况的直接链接" title="粘性定位失效的情况的直接链接">​</a></h3><ol><li>包裹的父容器高度与sticky元素一致</li><li>包裹的父容器设置了overflow为非visible</li><li>没有指定top, right, bottom 或 left</li></ol>]]></content:encoded>
            <category>Vue</category>
            <category>问题回顾</category>
        </item>
        <item>
            <title><![CDATA[箭头函数和普通函数区别]]></title>
            <link>https://qym994.github.io/qym-js-6</link>
            <guid>https://qym994.github.io/qym-js-6</guid>
            <pubDate>Wed, 01 Mar 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[箭头函数和普通函数的区别]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="箭头函数和普通函数的区别">箭头函数和普通函数的区别<a href="#箭头函数和普通函数的区别" class="hash-link" aria-label="箭头函数和普通函数的区别的直接链接" title="箭头函数和普通函数的区别的直接链接">​</a></h3><ol><li>箭头函数在创建时不会有'Construct'方法，没有构造能力，无proptotype属性</li><li>箭头函数没有'arguments'对象，和第一点都是不需要复用的原因</li><li>this的指向  </li></ol><ul><li>普通函数的this是动态的，是实际执行的时候确认的  <ul><li>以函数形式调用 this =&gt; window对象</li><li>以方法形式调用 this =&gt; 调用方法的对象</li><li>构造函数中 this =&gt; 新创建的对象</li></ul></li><li>箭头函数的this在创建的时候固定为外部函数的this</li><li>顺便复习一下this指向的改变方法(箭头函数无法更改)<ul><li>call 调用方式<code>fn.call(xxx)</code>传入的第一个参数会变成fn的this指向，后续的参数作为实参传入</li><li>apply 调用方式<code>fn.apply(xxx)</code>传入的第一个参数会变成fn的this指向，后续的参数使用数据作为实参传入</li><li>bind  调用方式<code>const newfn() = fn.bind(xxx)</code>传入的第一个参数会变成newfn的this指向,后续的参数会绑定给newfn的实参</li></ul></li></ul>]]></content:encoded>
            <category>JavaScript</category>
            <category>问题回顾</category>
        </item>
        <item>
            <title><![CDATA[vant轻提示不生效]]></title>
            <link>https://qym994.github.io/qym-vue-4</link>
            <guid>https://qym994.github.io/qym-vue-4</guid>
            <pubDate>Mon, 20 Feb 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[vant轻提示不生效]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="vant轻提示不生效">vant轻提示不生效<a href="#vant轻提示不生效" class="hash-link" aria-label="vant轻提示不生效的直接链接" title="vant轻提示不生效的直接链接">​</a></h3><p>Vant 中有个别组件是以函数的形式提供的<br>
<!-- -->包括 Toast，Dialog，Notify 和 ImagePreview 组件<br>
<!-- -->在使用函数组件时，unplugin-vue-components 无法自动引入对应的样式，因此需要手动引入样式<br>
<!-- -->引入Notify组件<code>import 'vant/es/notify/style'</code><br>
<!-- -->引入Toast组件<code>import 'vant/es/toast/style'</code></p>]]></content:encoded>
            <category>Vue</category>
            <category>问题回顾</category>
            <category>vant</category>
        </item>
        <item>
            <title><![CDATA[vue3深层代理]]></title>
            <link>https://qym994.github.io/qym-vue-3</link>
            <guid>https://qym994.github.io/qym-vue-3</guid>
            <pubDate>Sun, 12 Feb 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[vue3深层代理]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="vue3深层代理">vue3深层代理<a href="#vue3深层代理" class="hash-link" aria-label="vue3深层代理的直接链接" title="vue3深层代理的直接链接">​</a></h3><p>为啥发现这个问题是我在做项目时发现vant引入的Form表单失去焦点自动提交<br>
<!-- -->原因是没有声明变量接受变量，但在setup语法糖中出现了问题：用数组接收表单数据报错<br>
<!-- -->校验发现必须单独申明v-model也就是表单input中的每一个变量<br>
<!-- -->错以为是reactive的代理是浅层的<br>
<!-- -->只能舍弃语法糖写法，在setup()函数中声明，最后return{...toRefs(userinfo)}
reactive()返回的是一个对象的深层代理<br>
<!-- -->shallowReactive()创建的是一个对象的浅层代理</p>]]></content:encoded>
            <category>Vue</category>
            <category>问题回顾</category>
            <category>vant</category>
        </item>
        <item>
            <title><![CDATA[响应式原理]]></title>
            <link>https://qym994.github.io/qym-vue-2</link>
            <guid>https://qym994.github.io/qym-vue-2</guid>
            <pubDate>Tue, 07 Feb 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[响应式原理]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="响应式原理">响应式原理<a href="#响应式原理" class="hash-link" aria-label="响应式原理的直接链接" title="响应式原理的直接链接">​</a></h3><p>只有被vue代理的对象才是响应式的，vue3中使用代理模式完成对象的响应式改造<br>
<!-- -->响应式数据可以通过组件实例直接访问<br>
<!-- -->普通对象在被修改时不会触发元素的重新渲染  </p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const obj={name:qym}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//handler用来指定代理的行为</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const handler = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    get(target,prop,recevier){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //target:被代理的对象 prop读取的属性 recevier代理对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return target[prop]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        track()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    set(target,prop,recevier.value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //前三个参数同上，value是修改的属性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    target[prop] = value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    trigger()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const proxy = new Proxy(obj,handler) //创建代理对象 </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码中核心是track方法和trigger方法<br>
<strong>track：在vue代理读取属性时会先进行追踪，记录使用该值的位置<br>trigger: 修改被代理的值后，触发所有track记录的位置进行更新</strong></p>]]></content:encoded>
            <category>Vue</category>
            <category>问题回顾</category>
        </item>
        <item>
            <title><![CDATA[通过 url 传递参数控制页面显示数据的两种方式]]></title>
            <link>https://qym994.github.io/qym-node.js-1</link>
            <guid>https://qym994.github.io/qym-node.js-1</guid>
            <pubDate>Fri, 03 Feb 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[通过 url 传递参数控制页面显示数据的两种方式]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="通过-url-传递参数控制页面显示数据的两种方式">通过 url 传递参数控制页面显示数据的两种方式<a href="#通过-url-传递参数控制页面显示数据的两种方式" class="hash-link" aria-label="通过 url 传递参数控制页面显示数据的两种方式的直接链接" title="通过 url 传递参数控制页面显示数据的两种方式的直接链接">​</a></h3><ol><li>query查询字符串传参
get请求默认通过查询字符串传递参数，服务器端以<code>/xxx?y=z</code>的形式接受"参数</li><li>param传参
get请求可以以param的形式传参<code>/xxx/:y</code><br><strong>query 传参配置的是path，而params传参配置的是name，query传递的参数会显示在地址栏中</strong><strong>query在路由配置不需要设置参数，而params必须设置(指定"：y")</strong></li><li>二者思想区别
约定优于配置：query传递参数需要指定属性名，param在配置路由时已经指定完毕<br>换句话说query需要配置属性名，而param已经约定好了传参时不用再配置</li></ol>]]></content:encoded>
            <category>Node.Js</category>
            <category>问题回顾</category>
        </item>
        <item>
            <title><![CDATA[在外部的js文件中使用pinia store中的数据报错未挂载pinia]]></title>
            <link>https://qym994.github.io/qym-vue-1</link>
            <guid>https://qym994.github.io/qym-vue-1</guid>
            <pubDate>Sat, 28 Jan 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[在外部的js文件中使用pinia store中的数据报错未挂载pinia]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="在外部的js文件中使用pinia-store中的数据报错未挂载pinia">在外部的js文件中使用pinia store中的数据报错未挂载pinia<a href="#在外部的js文件中使用pinia-store中的数据报错未挂载pinia" class="hash-link" aria-label="在外部的js文件中使用pinia store中的数据报错未挂载pinia的直接链接" title="在外部的js文件中使用pinia store中的数据报错未挂载pinia的直接链接">​</a></h3><p>写路由时需要用到store里的用户登录状态,报错为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">`Error: [🍍]: getActivePinia was called with no active Pinia. Did you forget to install pinia?  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const pinia = createPinia()  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">app.use(pinia)`</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>解决方法创建store时，导出pinia实例 </p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">import { createPinia } from 'pinia';</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const pinia = createPinia()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">export default pinia</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在使用时传递pinia实例  </p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">import pinia from "../store/user"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import { useUserStore } from "../store/user";</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const store = useUserStore(pinia)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
            <category>Vue</category>
            <category>问题回顾</category>
            <category>pinia</category>
        </item>
        <item>
            <title><![CDATA[可变参数]]></title>
            <link>https://qym994.github.io/qym-js-5</link>
            <guid>https://qym994.github.io/qym-js-5</guid>
            <pubDate>Sat, 21 Jan 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[arguments]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="arguments">arguments<a href="#arguments" class="hash-link" aria-label="arguments的直接链接" title="arguments的直接链接">​</a></h3><p>arguments是函数中的隐含参数，是一个伪数组对象，用来存储函数的实参<br>
<!-- -->无论用户是否定义形参，实参都会存到arguments对象中，可以通过索引读取实参  </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="可变参数">可变参数<a href="#可变参数" class="hash-link" aria-label="可变参数的直接链接" title="可变参数的直接链接">​</a></h3><p>可变参数<code>...args</code>在定义函数时将参数指定为可变参数<br>
<!-- -->可变参数<code>args</code>是一个数组可以使用数组的方法，可以命名，也可以配合其他参数</p>]]></content:encoded>
            <category>JavaScript</category>
            <category>问题回顾</category>
        </item>
        <item>
            <title><![CDATA[事件传播]]></title>
            <link>https://qym994.github.io/qym-js-4</link>
            <guid>https://qym994.github.io/qym-js-4</guid>
            <pubDate>Sun, 15 Jan 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[事件对象event]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="事件对象event">事件对象event<a href="#事件对象event" class="hash-link" aria-label="事件对象event的直接链接" title="事件对象event的直接链接">​</a></h3><p>事件对象是浏览器在事件触发时创建的对象，其中封装了事件相关的各种信息<br>
<!-- -->在事件的回调函数中定义一个形参接受事件对象，例如：<br>
<code>const box.onmousemove = function(event){this/event.target}</code>    </p><ul><li>在事件的响应函数中<code>event.target</code>表示触发事件的对象</li><li><code>this</code>表示绑定事件的对象  </li><li><code>event.stopPropagation()</code> 取消事件传导  </li><li><code>event.preventDefault</code>取消默认行为，例如取消表单提交，超链接跳转</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="事件的传播机制">事件的传播机制<a href="#事件的传播机制" class="hash-link" aria-label="事件的传播机制的直接链接" title="事件的传播机制的直接链接">​</a></h3><p>DOM中事件传播分为三个阶段：1.捕获阶段 2.目标阶段 3.冒泡阶段 </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="事件的冒泡bubble">事件的冒泡(bubble)<a href="#事件的冒泡bubble" class="hash-link" aria-label="事件的冒泡(bubble)的直接链接" title="事件的冒泡(bubble)的直接链接">​</a></h3><p>事件的冒泡就是指事件的向上传导</p><ul><li>当元素上的事件触发时，其祖先元素的相同事件也会触发 后代触发=&gt;父类触发=&gt;祖先触发  </li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="事件的委派">事件的委派<a href="#事件的委派" class="hash-link" aria-label="事件的委派的直接链接" title="事件的委派的直接链接">​</a></h3><p>本该绑定给多个元素的事件，统一绑定给document，由于事件的冒泡，所有的document中的元素都会触发事件
这样可以降低代码复杂度维护，利用<code>event.target</code>做触发判断就可以了<br>
<!-- -->给 父元素注册事件 ，当我们触发子元素的时候，会冒泡到父元素身上，从而触发父元素的事件</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="事件的捕获">事件的捕获<a href="#事件的捕获" class="hash-link" aria-label="事件的捕获的直接链接" title="事件的捕获的直接链接">​</a></h3><p>事件由外到内的传播，事件触发后会从当前元素最大的祖先元素开始向当前元素进行事件捕获
如果希望在捕获阶段触发事件将<code>addEventListener</code>的第三个参数设置为true</p>]]></content:encoded>
            <category>JavaScript</category>
            <category>问题回顾</category>
        </item>
        <item>
            <title><![CDATA[常用的数组方法]]></title>
            <link>https://qym994.github.io/qym-js-3</link>
            <guid>https://qym994.github.io/qym-js-3</guid>
            <pubDate>Wed, 11 Jan 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[常用的数组方法]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="常用的数组方法">常用的数组方法<a href="#常用的数组方法" class="hash-link" aria-label="常用的数组方法的直接链接" title="常用的数组方法的直接链接">​</a></h3><ol><li><code>Array.push()</code>将传入的参数追加到原数组的末尾，push方法可传多个参数和单个参数  </li></ol><ul><li><strong>如果传入另一个数组将不会拆分，会作为整体即一个子元素传入(可用...展开数组)</strong></li></ul><ol start="2"><li><code>Array.forEach((item,index,thisArr)=&gt;{})</code></li></ol><ul><li>item当前遍历到的元素，index遍历到的元素索引，thisArr表示当前数组
3.<code>Array.map((item,index,thisArr)=&gt;{retrun xxx})</code>  </li><li>参数同上 <strong>xxx表示对数组的处理</strong><br>4.<code>Array.filter((item,index,thisArr)=&gt;{retrun xxx})</code>  </li><li>参数同上 <strong>xxx表示过滤的条件(判断语句)</strong><br>5.<code>Array.splice()</code>  </li><li>传入两个参数时进行删除，第一个参数是开始删除的索引，第二个参数是删除的元素个数</li><li>传入三个参数时进行修改，第一个参数是插入的索引，第二个参数修改的元素个数，第三个参数是修改的元素</li></ul>]]></content:encoded>
            <category>JavaScript</category>
            <category>问题回顾</category>
        </item>
        <item>
            <title><![CDATA[Esmodule和Commonjs规范]]></title>
            <link>https://qym994.github.io/qym-js-2</link>
            <guid>https://qym994.github.io/qym-js-2</guid>
            <pubDate>Sat, 07 Jan 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Esmodule和Commonjs规范]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="esmodule和commonjs规范">Esmodule和Commonjs规范<a href="#esmodule和commonjs规范" class="hash-link" aria-label="Esmodule和Commonjs规范的直接链接" title="Esmodule和Commonjs规范的直接链接">​</a></h3><p>commonjs和esmodule是目前前端主要的模块化方案</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="commonjs">Commonjs<a href="#commonjs" class="hash-link" aria-label="Commonjs的直接链接" title="Commonjs的直接链接">​</a></h4><p>commonjs也叫cjs,在node中每一个js文件都是一个单独的模块<br>
<!-- -->这个模块中包含CommonJS的规范的核心变量: <strong>exports， module.exports, require</strong><br>
<!-- -->exports和module.exports可以负责对模块中的内容进行导出    </p><ul><li>exports和module.exports本来指向的是同一个引用地址，但是真正导入的是module.exports   </li><li>require函数可以帮助我们导入其他模块（自定义模块，系统模块，第三方库）<br><strong>注意</strong>  commonjs加载是同步的，所以必须等到相应的模块加载完毕，才执行后续代码<br>在浏览器环境中同步请求资源可能会引起卡顿<br>加载模块的时候，每一个模块上会有一个 loaded 布尔值属性避免重复加载  </li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="esmodule">Esmodule<a href="#esmodule" class="hash-link" aria-label="Esmodule的直接链接" title="Esmodule的直接链接">​</a></h4><p>ES Module 使用 import导入 和 export导出</p><ul><li>默认导出的情况下可以不指定名字，引入也可以不使用"{}"并自己命名
<strong>使用 ES Module 将会自动开启严格模式</strong></li></ul>]]></content:encoded>
            <category>模块化</category>
            <category>问题回顾</category>
            <category>node.js</category>
        </item>
        <item>
            <title><![CDATA[正则表达式]]></title>
            <link>https://qym994.github.io/qym-js-1</link>
            <guid>https://qym994.github.io/qym-js-1</guid>
            <pubDate>Sun, 01 Jan 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[正则表达式]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="正则表达式">正则表达式<a href="#正则表达式" class="hash-link" aria-label="正则表达式的直接链接" title="正则表达式的直接链接">​</a></h3><p>写项目的时候遇到了表单验证的问题，即确定用户的提交内容是否合法<br>
<!-- -->问题在于用户名，密码以及邮箱的格式是否合规</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1-定义">1. 定义<a href="#1-定义" class="hash-link" aria-label="1. 定义的直接链接" title="1. 定义的直接链接">​</a></h4><blockquote><p>正则表达式是一个规则<br>
<!-- -->通过这个规则计算机可以检查一个字符串是否符合规则  </p></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="2-创建方式">2. 创建方式<a href="#2-创建方式" class="hash-link" aria-label="2. 创建方式的直接链接" title="2. 创建方式的直接链接">​</a></h4><blockquote><p>通过构造函数创建：
<code>let reg = new RegExp("reg","model")</code><br>
<!-- -->reg是正则本身，model是匹配模式<br>
<!-- -->通过字面量创建：
<code>reg = /reg/model</code><br>
<!-- -->参数意义同上<br>
<strong>注意</strong>：构造函数可以用变量指定正则(reg)<br>
<!-- -->转义字符<code>\</code>在函数中会自动转义一次，如需限制字符"\"要写为<code>\\</code>  </p></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="3使用">3.使用<a href="#3使用" class="hash-link" aria-label="3.使用的直接链接" title="3.使用的直接链接">​</a></h4><blockquote><ul><li>最常用的用法"匹配" ：<code>let result = reg.test(str)</code><br>str是待测项目 reg是正则表达式 result是返回的结果(布尔值)  </li><li>过滤:<code>let result = reg.exec(str)</code>提取出str中符合正则表达式的内容
<strong>注意</strong>result的结构为<code>['a','b',index:number,input:string,groups:undefined]</code>
a是符合匹配规则的整体,b是分组内容即"()"里的内容"可有多个b,index表示a在整个result中的序号,input表示输入的str
groups表示具名匹配,允许为每一个组匹配指定一个名字 ,在组中用<code>&lt;&gt;</code>命名</li></ul></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="4reg常用语法">4."reg"常用语法<a href="#4reg常用语法" class="hash-link" aria-label="4.&quot;reg&quot;常用语法的直接链接" title="4.&quot;reg&quot;常用语法的直接链接">​</a></h4><blockquote><ol><li><code>|</code> 表示或</li><li><code>[]</code> 表示字符集</li></ol><ul><li><code>[a-z]</code>表示小写字母a到z</li><li><code>[A-Z]</code>表示大写字母A到Z</li><li><code>[a-zA-Z]</code>表示任意字母  </li></ul><ol start="3"><li><code>[^]</code>表示字符集取反,例如<code>reg=/[^x]/</code>即除了x之外任意字符串</li><li><code>.</code>表示除了换行"\"以外的任意字符串,如需检查"."使用<code>\.</code></li><li><code>^</code>表示字符串开头</li><li><code>$</code>表示表示字符串结尾 <strong>注意</strong><code>^</code>和<code>$</code>常与其他正则组合使用,例如<code>/^x$/</code>表示只匹配x(完全匹配)</li><li>常用字符集  </li></ol><ul><li><code>/w</code>表示基本拉丁字母中的任意字母数字字符,包括下划线,即<code>/[a-zA-z0-9_]</code></li><li><code>/W</code>表示<code>/w</code>取反,即<code>/[^a-zA-z0-9_]</code></li><li><code>/d</code>表示数字,即<code>[0-9]</code></li><li><code>/D</code>表示<code>/d</code>取反,即<code>[^0-9]</code></li></ul><ol start="8"><li>量词</li></ol><ul><li><code>{m}</code>表示恰好m个只对前面的字符使用,可使用"()"进行量词分组<br>例如<code>/a{3}/</code>匹配"aaa",<code>/(ab){3}/</code>匹配"ababab"</li><li><code>{m,n}</code>表示m到n个之间</li><li><code>{m,}</code>表示至少m个</li><li><code>{+}</code>表示至少一个,即<code>{1,}</code></li><li><code>*</code>表示任意数量,即有不报错多了也可以</li><li><code>?</code>表示0或者1茨,即<code>{0,1}</code></li></ul></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="5model匹配模式">5."model"匹配模式<a href="#5model匹配模式" class="hash-link" aria-label="5.&quot;model&quot;匹配模式的直接链接" title="5.&quot;model&quot;匹配模式的直接链接">​</a></h4><blockquote><ol><li><code>i</code>表示忽略大小写,例如<code>/[a-z]/i</code></li><li><code>g</code>表示全局匹配.默认正则表达式只匹配第一个符合条件的字符串,找到即终止  </li></ol></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="6常用正则表达式">6.常用正则表达式<a href="#6常用正则表达式" class="hash-link" aria-label="6.常用正则表达式的直接链接" title="6.常用正则表达式的直接链接">​</a></h4><blockquote><ol><li>用户名正则，4到16位（字母，数字，下划线，减号）<br><code>let uPattern = /^[a-zA-Z0-9_-]{4,16}$/</code></li><li>//密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字<br><code>let pPattern = /^.*(?=.{6,})(?=.*\d)(?=.*[A-Z])(?=.*[a-z]).*$/</code>  </li><li>//Email正则<br><code>let ePattern = /^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]{2,4})$/</code></li></ol></blockquote>]]></content:encoded>
            <category>JavaScript</category>
            <category>问题回顾</category>
        </item>
        <item>
            <title><![CDATA[nextTick]]></title>
            <link>https://qym994.github.io/auditon-8</link>
            <guid>https://qym994.github.io/auditon-8</guid>
            <pubDate>Mon, 08 Jan 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[nextTick]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="nexttick">nextTick<a href="#nexttick" class="hash-link" aria-label="nextTick的直接链接" title="nextTick的直接链接">​</a></h3><ol><li>定义：nextTick是等待下一次DOM更新刷新的工具方法</li><li>事件循环eventlopp</li></ol><ul><li>调用栈：当一个函数被调用时，它的执行环境会作为一个栈帧(frame)插入栈顶，函数执行完毕会自动弹出栈帧</li><li><ul><li>其实可以从调用栈看出函数作用域的包含关系</li></ul></li><li>消息队列：存储将要执行的函数，触发一个事件时，不是直接把事件放到调用栈中，而是放到消息队列中排队</li><li><ul><li><strong>定时器的本质是指定时间后将函数添加到消息队列</strong></li></ul></li><li>微任务队列：</li></ul><ol><li>vue的异步更新策略：如果数据发生变化，vue不会立即更新DOM，而是开启一个队列，把组件更新函数保存在队列中，在同一事件循环中发生的数据</li></ol>]]></content:encoded>
            <category>面试准备</category>
            <category>vue</category>
        </item>
        <item>
            <title><![CDATA[history和hash模式]]></title>
            <link>https://qym994.github.io/auditon-7</link>
            <guid>https://qym994.github.io/auditon-7</guid>
            <pubDate>Sun, 07 Jan 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[v-router有三个模式]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="v-router有三个模式">v-router有三个模式<a href="#v-router有三个模式" class="hash-link" aria-label="v-router有三个模式的直接链接" title="v-router有三个模式的直接链接">​</a></h3><p>hash模式 history模式 memory模式
区别只在url形式 </p><ol><li>hash：<code>http://xxx.com/#/yyy</code></li></ol><ul><li>在url栏中显示已hash的形式，使用部署更简单  </li></ul><ol start="2"><li>history:<code>http://xxx.com/yyy</code></li></ol><ul><li>在url栏中更简洁美观，应用时需要配置，web服务器需要做回退处理，否则会出现刷新404的问题</li></ul>]]></content:encoded>
            <category>面试准备</category>
            <category>vue</category>
            <category>v-router</category>
        </item>
        <item>
            <title><![CDATA[ref和reacitive]]></title>
            <link>https://qym994.github.io/auditon-6</link>
            <guid>https://qym994.github.io/auditon-6</guid>
            <pubDate>Sat, 06 Jan 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[ref和reacitive]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="ref和reacitive">ref和reacitive<a href="#ref和reacitive" class="hash-link" aria-label="ref和reacitive的直接链接" title="ref和reacitive的直接链接">​</a></h3><ol><li>ref</li></ol><ul><li>ref用来处理单值的响应式</li><li>在scipt中如需访问ref响应式数据需要加上<code>.value</code>才能正常访问  </li><li>通过内部封装一个Reflmpl类并设置get和set方法实现响应式</li></ul><ol start="2"><li>reacitive</li></ol><ul><li>reactive用来处理对象的响应式</li><li>使用展开运算符(...)展开reactive的响应式对象会使其失去响应式，可结合toRefs再展开</li><li>通过借助Proxy代理对象实现响应式</li></ul>]]></content:encoded>
            <category>面试准备</category>
            <category>vue</category>
        </item>
        <item>
            <title><![CDATA[双向绑定]]></title>
            <link>https://qym994.github.io/auditon-5</link>
            <guid>https://qym994.github.io/auditon-5</guid>
            <pubDate>Fri, 05 Jan 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[双向绑定]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="双向绑定">双向绑定<a href="#双向绑定" class="hash-link" aria-label="双向绑定的直接链接" title="双向绑定的直接链接">​</a></h3><ol><li>定义：双向绑定就是v-model，将一个响应式数据绑定到视图<br>视图变化能改变该值，数据变化也能改变视图</li><li>v-model是一个语法糖，默认情况下相当于<code>：value</code>和<code>@input</code>通常在表单项中使用</li><li>表单单选type="checkbox"可以结合true-value和false-value  </li></ol><ul><li><code>const text = ref("是")</code></li><li><code>&lt;input type = checkbox v-model = text true-value="是" false-value = "否"/&gt;</code> </li></ul><ol start="4"><li>表单多选type="checkbox"与单选方法相同，使用一个响应式的数据接收数据</li><li>如需要选项控制其他元素的可操作性，例如：同意隐私设置登录<br>可以结合<code>:disabled</code>取反"同意选项"<br><strong>假如表达需要默认为空，则v-model绑定一个空的响应式数据即可</strong></li></ol>]]></content:encoded>
            <category>面试准备</category>
            <category>vue</category>
        </item>
        <item>
            <title><![CDATA[v-for/v-if]]></title>
            <link>https://qym994.github.io/auditon-4</link>
            <guid>https://qym994.github.io/auditon-4</guid>
            <pubDate>Thu, 04 Jan 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[v-for和v-if]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="v-for和v-if">v-for和v-if<a href="#v-for和v-if" class="hash-link" aria-label="v-for和v-if的直接链接" title="v-for和v-if的直接链接">​</a></h3><p><strong>实际使用中不要将v-for和v-if一起使用</strong><br>
<strong>性能消耗v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销</strong></p><ol><li>v-show</li></ol><ul><li>v-show通过css样式的display：none控制元素显隐  </li><li>当用v-show来隐藏元素时，只会在初次加载时渲染此dom节点，之后都是通用display来控制显隐，</li></ul><ol start="2"><li>v-if  </li></ol><ul><li>v-if通过直接控制虚拟DOM中的元素节点间接控制真实DOM上的节点控制元素显隐   </li><li>当用v-if来隐藏元素时，初次加载时就不用渲染此dom节点，提升页面加载速度</li></ul>]]></content:encoded>
            <category>面试准备</category>
            <category>vue</category>
        </item>
        <item>
            <title><![CDATA[数据持久化和本地存储]]></title>
            <link>https://qym994.github.io/auditon-3</link>
            <guid>https://qym994.github.io/auditon-3</guid>
            <pubDate>Wed, 03 Jan 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[vuex中的state数据丢失]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="vuex中的state数据丢失">vuex中的state数据丢失<a href="#vuex中的state数据丢失" class="hash-link" aria-label="vuex中的state数据丢失的直接链接" title="vuex中的state数据丢失的直接链接">​</a></h3><ol><li>原因：vuex存储的数据只是在页面中，相当于全局变量，页面刷新的时候vuex里的数据会重新初始化，导致数据丢失。
因为vuex里的数据是保存在运行内存中的，当页面刷新时，页面会重新加载vue实例，vuex里面的数据就会被重新赋值</li><li>解决方法：将vuex中的数据直接保存到浏览器缓存中（sessionStorage、localStorage、cookie）</li></ol><ul><li>直接在vuex修改数据方法中将数据存储到浏览器本地存储中 </li><li>引入第三方库进行持久化存储</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="pinia数据持久化">pinia数据持久化<a href="#pinia数据持久化" class="hash-link" aria-label="pinia数据持久化的直接链接" title="pinia数据持久化的直接链接">​</a></h3><ol><li>安装插件persist</li><li>在App.vue中引入并挂载</li><li>数据缓存并配置</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="本地存储">本地存储<a href="#本地存储" class="hash-link" aria-label="本地存储的直接链接" title="本地存储的直接链接">​</a></h3><ol><li>sessionStorage会话存储<code>sessionStorage.setItem("属性名"，"属性值")</code></li><li>logcalStorage本地存储<code>localStorage.setItem("属性名","属性值")</code></li><li>会话存储和本地存储都有相同的方法setItem,getItem,removeItem,clear</li></ol>]]></content:encoded>
            <category>面试准备</category>
            <category>vuex</category>
            <category>pinia</category>
            <category>vue</category>
        </item>
        <item>
            <title><![CDATA[http状态码]]></title>
            <link>https://qym994.github.io/auditon-2</link>
            <guid>https://qym994.github.io/auditon-2</guid>
            <pubDate>Tue, 02 Jan 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[http状态码]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="http状态码">http状态码<a href="#http状态码" class="hash-link" aria-label="http状态码的直接链接" title="http状态码的直接链接">​</a></h3><ol><li>定义：http状态码是服务器返回客户端的响应状态码</li><li>具体分类</li></ol><ul><li>1xx：表示通知信息，如请求收到了或正在处理</li><li><ul><li>100：Continue 客户端继续其请求</li></ul></li><li><ul><li>101：Switching Protocols 服务器切换更高级协议</li></ul></li><li>2xx：表示成功，如接受或知道了  </li><li><ul><li>200：OK 请求成功</li></ul></li><li><ul><li>201：Created 成功请求并创建资源</li></ul></li><li><ul><li>202 ：Accepted 已接受请求但还未处理</li></ul></li><li>3xx：表示重定向：如要完成请求还需要进一步行动</li><li><ul><li>301：Moved Permanently 请求的资源已经被永久移动新URI，浏览器会重新定向到新URI</li></ul></li><li><ul><li>302：Found 请求的资源临时移动，不重定向URI</li></ul></li><li>4xx：表示客户端错误，如请求中有错误的语法或不能完成</li><li><ul><li>400：Bad Request 客户端请求的语法错误</li></ul></li><li><ul><li>401：Unauthorized 客户端身份验证未通过j</li></ul></li><li><ul><li>403：Forbidden 服务器拒绝执行请求</li></ul></li><li><ul><li>404：Not Found 服务器无法找到请求的资源</li></ul></li><li>5XX：表示服务器端错误，如服务器失效</li><li><ul><li>502：Bad Gateway 错误网关</li></ul></li></ul>]]></content:encoded>
            <category>面试准备</category>
            <category>计算机网络</category>
        </item>
        <item>
            <title><![CDATA[vue中组件通信]]></title>
            <link>https://qym994.github.io/auditon-1</link>
            <guid>https://qym994.github.io/auditon-1</guid>
            <pubDate>Mon, 01 Jan 1900 00:00:00 GMT</pubDate>
            <description><![CDATA[vue中组件通信]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="vue中组件通信">vue中组件通信<a href="#vue中组件通信" class="hash-link" aria-label="vue中组件通信的直接链接" title="vue中组件通信的直接链接">​</a></h3><ol><li>父子组件通信</li></ol><ul><li>props </li><li><ul><li>子组件使用<code>const props = defineProps([x,y,z])</code>定义属性名，可以传入对象进行配置  </li></ul></li><li><ul><li>父组件中在创建子组件实例时使用子组件定义的属性名传递参数  </li></ul></li><li><ul><li><strong>父组件传递给子组件的props是只读的</strong></li></ul></li><li>属性透传</li><li><ul><li>在组件中设置属性，会自动传递给子组件的根元素，会继续传递给子元素</li></ul></li><li><ul><li>透传会发生在没有被声明为props和emit的属性上</li></ul></li><li><ul><li><strong>*自动透传只能传递给单根子组件</strong></li></ul></li><li><ul><li>模板中使用$attr手动访问透传属`性，在scipt中使用useAttrs()获取透传属性</li></ul></li><li><ul><li>在script标签中(非setup语法糖)使用<code>inheritAttrs：false</code>设置不发生自动透传  </li></ul></li><li>emits</li><li><ul><li>在子元素中使用<code>const emits = defineEmits([xxx])</code>定义事件名</li></ul></li><li><ul><li>在父元素中<code>@xxx = emits(yyy)</code>给xxx绑定yyy事件触发  </li></ul></li><li>ref</li><li><ul><li>给DOM节点添加ref属性，即起别名，通过$refs属性获取该节点</li></ul></li><li><ul><li>给组件添加ref属性，即起别名，通过$refs调用获取中的属性，方法</li></ul></li><li><ul><li>假如同时使用ref添加响应式数据需要指定同一属性名<code>const x = ref(null) </code></li></ul></li><li><ul><li><strong>vue3中ref获取节点所以必须在mounted之后才能获取到元素，因为setup执行时，template中的元素还没挂载到页面上</strong></li></ul></li><li>依赖注入</li><li><ul><li>在祖先组件中设置依赖<code>provide(name,value)</code></li></ul></li><li><ul><li>在后代组件中注入数据<code>const value = inject(name,default)</code></li></ul></li><li><ul><li>若有同名依赖取最近一层的祖先元素依赖</li></ul></li><li>状态管理工具</li><li>使用pinia或vuex等状态管理工具进行全局的数据控制</li></ul>]]></content:encoded>
            <category>面试准备</category>
            <category>vue</category>
        </item>
    </channel>
</rss>